<!doctype html public "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<html>
<head>
<title>
 Overview
</title>
<link rel ="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script>
function asd() {
        
                parent.document.title="commportal.js Overview";
        
}
</script>
</head>
<body bgcolor="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">

  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev"> &nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1">    <font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top">
<em>
<b></b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<center>
        
           <h2>commportal.js</h2>
        
</center>

        


<h4>Summary</h4>
<p>
        
                <p>
 The CommPortal JavaScript API provides simplified access to the data made
 available via the CommPortal JSON interface.
 </p>

 <p>
 Including this file will define just one object in the JavaScript global
 scope, the <a href="CommPortal.html#">CommPortal</a> object.
 </p>

 <p>
 All interaction with the API is through either the global
 <a href="CommPortal.html#">CommPortal</a> object, or via other objects returned via the various
 method calls on that object.
 </p>

 <p>
 The other objects used within the interface are all simple JavaScript
 objects (they are not "instanceof" anything other than Object), though for
 documentation purposes they are listed here as if they are in lowercased
 pseudo classes named thus:
 </p>
 <ul>
   <li><a href="address.html#">address</a></li>
   <li><a href="call.html#">call</a></li>
   <li><a href="callstate.html#">callstate</a></li>
   <li><a href="contact.html#">contact</a></li>
   <li><a href="error.html#">error</a></li>
   <li><a href="fax.html#">fax</a></li>
   <li><a href="voicemail.html#">voicemail</a></li>
   <li><a href="greetings.html#">greetings</a></li>
   <li><a href="greeting.html#">greeting</a></li>
 </ul>

 <p>
 Similarly a pseudo class of <a href="callbacks.html#">callbacks</a> is used as a documentation
 device to allow the method signatures of the various callbacks used within
 the API to be documented.
 </p>

 <p>
 For the sake of convenience, including this file will also define the JSON
 namespace if that is not already defined, which it does by including the
 following external file
 </p>
 <ul>
   <li>json2.js</li>
 </ul>

 See <a href="http://innovators.metaswitch.com">The MetaSwitch Innovators Community</a>
 for more details.<BR/><BR/><B>Version: </B>8.1
 <BR/><BR/>
        
</p>

<hr>


    <table border="1" cellpadding="3" cellspacing="0" width="100%">
    <tr bgcolor="#CCCCFF" class="TableHeadingColor">
    <td colspan=2><font size="+2">
    
        <b>Class Summary</b>
    
    </font></td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="address.html">address</a></b></td>
    <td>Pseudo class documenting the fields that form an address within a <a href="contact.html#">contact</a>.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="call.html">call</a></b></td>
    <td>Pseudo class documenting the fields that make up a call record.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="callbacks.html">callbacks</a></b></td>
    <td>The methods described here are callback methods that various methods
 in the <a href="CommPortal.html#">CommPortal</a> SDK API call.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="callstate.html">callstate</a></b></td>
    <td>Pseudo class documenting the properties that make up a callstate passed to the
 <a href="callbacks.html#progressCallback">callbacks.progressCallback()</a> of a <a href="CommPortal.html#makeCall">CommPortal.makeCall()</a>.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="CommPortal.html">CommPortal</a></b></td>
    <td>See <a href="http://innovators.metaswitch.com">Innovators</a> for more details.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="contact.html">contact</a></b></td>
    <td>Pseudo class documenting the fields that describe a contact.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="error.html">error</a></b></td>
    <td>Pseudo class documenting the properties that make up an error passed to a
 <a href="callbacks.html#failureCallback">callbacks.failureCallback()</a>.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="fax.html">fax</a></b></td>
    <td>Pseudo class documenting the fields that describe a fax.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="greeting.html">greeting</a></b></td>
    <td>Pseudo class documenting the fields that describe greetings data.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="greetings.html">greetings</a></b></td>
    <td>Pseudo class documenting the fields that describe greetings data.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="incomingcalldata.html">incomingcalldata</a></b></td>
    <td>Pseudo class documenting the properties that make up a incomingcalldata
 passed to the <a href="callbacks.html#incomingCallback">callbacks.incomingCallback()</a> of a
 <a href="CommPortal.html#setIncomingCallHandler">CommPortal.setIncomingCallHandler()</a>.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="voicemail.html">voicemail</a></b></td>
    <td>Pseudo class documenting the fields that describe a voicemail.</td>
    </tr>
    
    </table>
    <hr/>


<!-- ========== METHOD SUMMARY =========== -->

<!-- ========== END METHOD SUMMARY =========== -->


        <pre class="sourceview"><span class="comment">/**
 * CommPortal JavaScript API v8.1
 * http://www.metaswitch.com/
 * http://innovators.metaswitch.com/
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Highly Confidential Material
 */</span>

<span class="comment">/**
 * <span class="attrib">@version</span> 8.1
 * <span class="attrib">@fileoverview</span>
 *
 * &lt;p&gt;
 * The CommPortal JavaScript API provides simplified access to the data made
 * available via the CommPortal JSON interface.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Including this file will define just one object in the JavaScript global
 * scope, the {<span class="attrib">@link</span> CommPortal} object.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * All interaction with the API is through either the global
 * {<span class="attrib">@link</span> CommPortal} object, or via other objects returned via the various
 * method calls on that object.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The other objects used within the interface are all simple JavaScript
 * objects (they are not "instanceof" anything other than Object), though for
 * documentation purposes they are listed here as if they are in lowercased
 * pseudo classes named thus:
 * &lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;{<span class="attrib">@link</span> address}&lt;/li&gt;
 *   &lt;li&gt;{<span class="attrib">@link</span> call}&lt;/li&gt;
 *   &lt;li&gt;{<span class="attrib">@link</span> callstate}&lt;/li&gt;
 *   &lt;li&gt;{<span class="attrib">@link</span> contact}&lt;/li&gt;
 *   &lt;li&gt;{<span class="attrib">@link</span> error}&lt;/li&gt;
 *   &lt;li&gt;{<span class="attrib">@link</span> fax}&lt;/li&gt;
 *   &lt;li&gt;{<span class="attrib">@link</span> voicemail}&lt;/li&gt;
 *   &lt;li&gt;{<span class="attrib">@link</span> greetings}&lt;/li&gt;
 *   &lt;li&gt;{<span class="attrib">@link</span> greeting}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * Similarly a pseudo class of {<span class="attrib">@link</span> callbacks} is used as a documentation
 * device to allow the method signatures of the various callbacks used within
 * the API to be documented.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * For the sake of convenience, including this file will also define the JSON
 * namespace if that is not already defined, which it does by including the
 * following external file
 * &lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;json2.js&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * See &lt;a href="http://innovators.metaswitch.com"&gt;The MetaSwitch Innovators Community&lt;/a&gt;
 * for more details.
 */</span>

(<span class="reserved">function</span>()
{
  <span class="comment">// Static variables</span>
  var sUniqueId = 0;
  var sRedirectFile = <span class="literal">"empty.txt"</span>;
  var sLoginPath = <span class="literal">"/login.html"</span>;

  <span class="comment">//CodeForTesting1 -- do not delete this line, it is used for automated testing</span>

  <span class="comment">// The CommPortal server interface version we pass on login.  This is the</span>
  <span class="comment">// latest version supported by this script.  It's not used in V7.1, since</span>
  <span class="comment">// we always specify the version explicitly on each request, but we</span>
  <span class="comment">// send it anyway in case it is useful to the server in future versions.</span>
  var LOGIN_VERSION = <span class="literal">"8.1"</span>;

  <span class="comment">// The default Client Version value used in logs to the Service Assurance</span>
  <span class="comment">// Server. The Client Version should be overwritten by users of the</span>
  <span class="comment">// CommPortal SDK by calling setClientVersion(version)</span>
  var DEFAULT_CLIENT_VERSION = <span class="literal">"8.1 (SDK)"</span>;

  <span class="comment">// Find where we were loaded from, since we need to be able to find other</span>
  <span class="comment">// files in the same directory.</span>
  <span class="comment">// Note that since we are being executed as a result of being included</span>
  <span class="comment">// then we will normally simply be the last script in the array...</span>
  var scripts = document.getElementsByTagName(<span class="literal">"script"</span>);
  <span class="reserved">for</span> (var i = scripts.length - 1; i &gt;= 0; i--)
  {
    var script = scripts[i];

    var src = script.src;
    <span class="reserved">if</span> (src.match(/(^|\/)commportal.js(\?.*)?$/))
    {
      var pathSplit = src.lastIndexOf(<span class="literal">"/"</span>);

      <span class="comment">// The sLibPath includes any trailing "/" that may be necessary</span>
      var sLibPath = pathSplit &gt; -1 ? src.substring(0, pathSplit + 1) : <span class="literal">""</span>;

      <span class="comment">// Commands are anything after the first "?" if present</span>
      <span class="reserved">if</span> (src.indexOf(<span class="literal">"?"</span>) &gt; -1)
      {
        var sCommands = src.substring(src.indexOf(<span class="literal">"?"</span>) + 1);
      }
      break;
    }
  }

  var sPageProtocolHost = document.location.protocol + <span class="literal">"//"</span> +
                          document.location.host;
  var sPagePath = sPageProtocolHost +
                  document.location.pathname.substring(0, document.location.pathname.lastIndexOf(<span class="literal">"/"</span>) + 1);

  <span class="comment">/**
   * Convert a URL into an absolute URL.  Relative URLs are assumed to be
   * relative to the current path.  Absolute URLs are unchanged.
   *
   * <span class="attrib">@private</span>
   * <span class="attrib">@param</span> {String} url the URL to make absolute
   * <span class="attrib">@return</span> an absolute URL
   */</span>
  <span class="reserved">function</span> toAbsoluteUrl(url)
  {
    <span class="comment">// Check if the URL is missing or already absolute.</span>
    <span class="reserved">if</span> ((url) &amp;&amp;
        (!url.match(/^https?:/i)))
    {
      <span class="comment">// The URL is relative.  However, it may specify a full path from the</span>
      <span class="comment">// root.  Check this.</span>
      <span class="reserved">if</span> (url.substring(0, 1) == <span class="literal">"/"</span>)
      {
        <span class="comment">// The relative URL starts with a /, so it just needs to be prefixed</span>
        <span class="comment">// with the protocol and host of the page.</span>
        url = sPageProtocolHost + url;
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// The relative URL doesn't start with a /, so it needs to be prefixed</span>
        <span class="comment">// with the full path to the page.</span>
        url = sPagePath + url;
      }
    }
    <span class="comment">// Resolve any .. path components in the URL by seeing if there are any</span>
    <span class="comment">// remaining, stripping them out (along with the preceding path components)</span>
    <span class="comment">// and then spinning round and trying again.</span>
    <span class="reserved">while</span> (1)
    {
      <span class="comment">// The following regular expression parses the URL into three sections:</span>
      <span class="comment">// 1) from the beginning up to and including the / before the path</span>
      <span class="comment">//    component before the ..</span>
      <span class="comment">// 2) the path component before the .., its /, the .. and the following /</span>
      <span class="comment">// 3) the rest of the URL</span>
      <span class="comment">//</span>
      <span class="comment">// For example, http://example.com/abcdef/../example.html would be parsed</span>
      <span class="comment">// as follows:</span>
      <span class="comment">// 1) http://example.com/</span>
      <span class="comment">// 2) abcdef/../</span>
      <span class="comment">// 3) example.html</span>
      <span class="comment">//</span>
      <span class="comment">// The regular expression works as follows.</span>
      <span class="comment">// /.../i - defines a case-insensitive regular expression</span>
      <span class="comment">// ^...$  - the regular expression must match the whole URL</span>
      <span class="comment">// (https?:\/\/(?:[^/]+\/)+?)</span>
      <span class="comment">//        - the first capturing group</span>
      <span class="comment">// https? - "http" followed by an optional "s"</span>
      <span class="comment">// :\/\/  - "://"</span>
      <span class="comment">// (?:[^/]+\/)</span>
      <span class="comment">//        - a non-capturing group that matches a single path component</span>
      <span class="comment">// [^\/]+\/</span>
      <span class="comment">//        - one or more non-/ characters followed by a /</span>
      <span class="comment">// +?     - allows for one or more of the previous element with a</span>
      <span class="comment">//          non-greedy match (i.e. match as few as possible), required</span>
      <span class="comment">//          because otherwise we match the last .. in the URL, not the</span>
      <span class="comment">//          first</span>
      <span class="comment">// ([^\/]+\/\.\.\/)</span>
      <span class="comment">//        - the second capturing group, matches one or more non-/</span>
      <span class="comment">//          characters followed by "/../"</span>
      <span class="comment">// (.*)   - the third capturing group, matching anything left in the URL</span>
      var match =
                /^(https?:\/\/(?:[^\/]+\/)+?)([^\/]+\/\.\.\/)(.*)$/i.exec(url);
      <span class="reserved">if</span> (match == null)
      {
        break;
      }
      url = match[1] + match[3];
    }
    <span class="reserved">return</span> url;
  }

  <span class="comment">// We need a valid absolute URL on the same server as the current page to</span>
  <span class="comment">// redirect to.  If we were loaded from the same server as the page, try the</span>
  <span class="comment">// file in that directory.  If not, just try the file in the same directory</span>
  <span class="comment">// as the page was loaded.  See {<span class="attrib">@link</span> CommPortal#setRedirectUrl} for more.</span>
  sLibPath = toAbsoluteUrl(sLibPath);
  <span class="reserved">if</span> ((sLibPath) &amp;&amp;
      (sLibPath.substring(0, sPageProtocolHost.length) == sPageProtocolHost))
  {
    var sRedirectUrl = sLibPath + sRedirectFile;
  }
  <span class="reserved">else</span>
  {
    var sRedirectUrl = sPagePath + sRedirectFile;
  }

  processCommands();

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> processCommands()
  {
    <span class="comment">// If we do not have a body yet, then try again later</span>
    <span class="reserved">if</span> (!document.body)
    {
      <span class="comment">// We delay processing the commands until the body exists</span>
      setTimeout(processCommands, 100);
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// Now work through any commands we may have been given</span>
      <span class="reserved">if</span> (sCommands)
      {
        var commands = sCommands.split(<span class="literal">","</span>);

        <span class="reserved">for</span> (var i = 0; i &lt; commands.length; i++)
        {
          var command = commands[i];

          <span class="comment">// No commands are actually defined yet.</span>
        }
      }
    }
  }

  <span class="comment">/**
   * The Main constructor object.
   * &lt;p&gt;
   * The object it returns embodies the full
   * CommPortal library's abilities, but will typically be thought of as an
   * object which simply implements one of the sub-interfaces, such as a
   * connection, or a call.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * The server URL can take the form "domain/cust" or a more specific path
   * "domain/cust/login.html" if the first option loads something other than
   * the plain login page.
   *
   * &lt;p&gt;
   * Possible flags are:
   * &lt;ul&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> #OPTIONS_USE_GET}&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * &lt;p&gt;The flags parameter is new in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@class</span>
   * See &lt;a href="http://innovators.metaswitch.com"&gt;Innovators&lt;/a&gt; for more details.
   *
   * &lt;p&gt;
   * This is the namespace for the CommPortal JavaScript API.
   *
   * &lt;p&gt;
   * There is a general convention followed in naming methods in this API.
   * &lt;/p&gt;
   * &lt;ul&gt;
   * &lt;li&gt;Methods named &lt;b&gt;fetchXXX()&lt;/b&gt; pass their values asynchrously to the supplied callback&lt;/li&gt;
   * &lt;li&gt;Methods named &lt;b&gt;getXXX()&lt;/b&gt; or &lt;b&gt;convertXXX()&lt;/b&gt; return their values immediately, as the return value&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * &lt;p&gt;
   * Other action verbs, such as &lt;b&gt;add&lt;/b&gt;, &lt;b&gt;modify&lt;/b&gt;, &lt;b&gt;delete&lt;/b&gt;,
   * &lt;b&gt;save&lt;/b&gt; and &lt;b&gt;mark&lt;/b&gt; also act asynchronously.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * Where a method can reasonably be expected to act on either a single
   * item, or a set of items, the parameter will accept either a single
   * item id (as a string), or an Array of such items.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {String} server [optional] server to connect to
   * <span class="attrib">@param</span> {Integer} flags [optional] flags to control optional behaviour
   */</span>
  <span class="reserved">function</span> CommPortal(server, flags)
  {
    <span class="comment">// If the first parameter is a string, then it is the server, otherwise</span>
    <span class="comment">// we shuffle all the parameters up since it has been omitted</span>
    <span class="reserved">if</span> (typeof server != <span class="literal">"string"</span>)
    {
      flags = server;
      server = undefined;
    }

    <span class="comment">/**
     * The CommPortal server interface version we use.  This is chosen during
     * login as a result of version negotiation.  All requests we make of the
     * CommPortal Server use this version.
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.interfaceVersion = null;

    <span class="comment">/**
     * The CommPortal client version we are using.  This defaults to the
     * version of this script (specified by DEFAULT_CLIENT_VERSION). This can
     * be overwritten by a call to setClientVersion.
     * {See {<span class="attrib">@link</span> commportal#setClientVersion}}
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.clientVersion = DEFAULT_CLIENT_VERSION;

    <span class="comment">/**
     * This private variable stores a callback function which is called in the
     * fetchData method if it is set, and retrieves the requested url.
     * {See {<span class="attrib">@link</span> callbacks#getRequestCallback}}
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.getRequestCallback = null;

    <span class="comment">/**
     * This private variable stores a callback function which is called in the
     * fetchData method if it is set, and retrieves the fetched data.
     * {See {<span class="attrib">@link</span> callbacks#getResponseCallback}}
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.getResponseCallback = null;

    <span class="comment">/**
     * This private variable stores a callback function which is called in the
     * saveData method if it is set, and retrieves the update request form.
     * {See {<span class="attrib">@link</span> callbacks#updateRequestCallback}}
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.updateRequestCallback = null;

    <span class="comment">/**
     * This private variable stores a callback function which is called in the
     * saveData method if it is set, and retrieves the update response redirect url.
     * {See {<span class="attrib">@link</span> callbacks#updateResponseCallback}}
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.updateResponseCallback = null;

    <span class="reserved">if</span> (flags)
    {
      <span class="comment">/** <span class="attrib">@private</span> */</span>
      <span class="reserved">this</span>.useGet = !!(flags &amp; CommPortal.OPTIONS_USE_GET);
    }

    <span class="comment">// Variables</span>

    <span class="comment">// Default the server if it is not given</span>
    <span class="comment">// Server validation is now done in login, which is the first call that</span>
    <span class="comment">// can return a failure indication.</span>
    <span class="comment">/** <span class="attrib">@private</span> */</span>
    <span class="reserved">this</span>.server = server || sPagePath;
    <span class="comment">/** <span class="attrib">@private</span> */</span>
    <span class="reserved">this</span>.serverLogin = <span class="reserved">this</span>.server;
    <span class="comment">// Remove the path to the login page from the server path</span>
    <span class="reserved">this</span>.server = <span class="reserved">this</span>.server.replace(sLoginPath, <span class="literal">""</span>);
    <span class="comment">/** <span class="attrib">@private</span> */</span>
    <span class="reserved">this</span>.originalServer = server;

    <span class="reserved">this</span>.invalidateCache();

    <span class="comment">// Giving each connection a unique id helps for debugging</span>
    <span class="comment">/** <span class="attrib">@private</span> */</span>
    <span class="reserved">this</span>.id = sUniqueId++;

    <span class="comment">/**
     * These private variables store the objects responsible for polling the
     * server to retrieve any event updates.  One is used to poll for updates
     * to telephone calls made by this SDK.  The other is for everything else.
     * A separate one is required for making telephone calls because a
     * different URL is used.  Note that when a telephone call is being made,
     * the polling for all other event types is paused to avoid any issues with
     * there being too many connections to the same server.
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.commPortalEvent = new CommPortalEvent();
    <span class="reserved">this</span>.callEvent = new CommPortalEvent();

    <span class="comment">/**
     * This private variable stores the current call state.
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.callState = CommPortal.CALLSTATE_INITIAL;

    <span class="comment">//CodeForTesting2 -- do not delete this line, it is used for automated testing</span>
  }

  <span class="comment">// Make the CommPortal object available in the Global scope</span>
  <span class="reserved">if</span> (<span class="literal">"CommPortal"</span> in window)
  {
    alert(<span class="literal">"Something has already defined the CommPortal object"</span>);
  }
  <span class="reserved">else</span>
  {
    window.CommPortal = CommPortal;
  }

  <span class="comment">// If the JSON namespace does not exist, then include it</span>
  <span class="reserved">if</span> (!(<span class="literal">"JSON"</span> in window) || !JSON.stringify)
  {
    document.write(<span class="literal">"&lt;script src='"</span> + sLibPath + <span class="literal">"json2.js'&gt;&lt;/script&gt;"</span>);
  }

  <span class="comment">// Options flags that can be passed to the constructor.</span>
  <span class="comment">// These should be added together if you need to set multiple options.</span>
  <span class="comment">// (They are all powers of two, so that they do not clash).</span>

  <span class="comment">/**
   * Options: Use GET request (rather than POST) for all URLs.
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.OPTIONS_USE_GET = 1;

  <span class="comment">/**
   * Error: Unknown error - no more details available.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_UNKNOWN              = 0;
  <span class="comment">/**
   * Error: Login window could not pop up.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_LOGIN_WINDOW_BLOCKED = 1;
  <span class="comment">/**
   * Error: Login window was closed without logging in.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_LOGIN_WINDOW_CLOSED  = 2;
  <span class="comment">/**
   * Error: Logging in was unsuccessful.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_LOGIN_ERROR          = 3;
  <span class="comment">/**
   * Error: Operation cannot proceed since you are not logged in.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_NOT_LOGGED_IN        = 4;
  <span class="comment">/**
   * Error: Cannot have an existing UID when creating a new contact.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_SUPPLIED_UID         = 5;
  <span class="comment">/**
   * Error: Must include a UID when modifying an existing contact.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_MISSING_UID          = 6;
  <span class="comment">/**
   * Error: The subscriber does not keep any call lists.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_NO_CALLLISTS         = 7;
  <span class="comment">/**
   * Error: Making a call gave an error
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_MAKE_CALL_ERROR      = 8;
  <span class="comment">/**
   * Error: Only allowed to have one call in progress.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_CALL_IN_PROGRESS     = 9;
  <span class="comment">/**
   * Error: There is no current call.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_NO_CURRENT_CALL      = 10;
  <span class="comment">/**
   * Error: Error reported fetching data from server
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_DATA_FETCH_ERROR     = 11;
  <span class="comment">/**
   * Error: Error reported saving data to server
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_DATA_SAVE_ERROR      = 12;
  <span class="comment">/**
   * Error: Cannot save cleaned data back to the server - it must be in raw format
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_NOT_RAW_DATA         = 13;
  <span class="comment">/**
   * Error: Session state provided on a reconnect is no longer valid
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_SESSION_STATE_INVALID = 14;
  <span class="comment">/**
   * Error: Token was generated with a newer SDK version
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_LOGIN_TOKEN_TOO_NEW  = 15;
  <span class="comment">/**
   * Error: Server string did not parse
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_SERVER_INVALID_FORMAT = 16;
  <span class="comment">/**
   * Error: Action data not recognized by the server
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_ACTION_INVALID_DATA  = 17;
  <span class="comment">/**
   * Error: No corresponding call handler currently set
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_NO_CORRESPONDING_HANDLER = 18;
  <span class="comment">/**
   * Error: Events are incompatible
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_INCOMPATIBLE_EVENTS  = 19;
  <span class="comment">/**
   * Error: Subscription not allowed
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_SUBSCRIPTION_NOT_ALLOWED  = 20;
  <span class="comment">/**
   * Error: Called line is busy.
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   *
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_LINE_BUSY  = 21;
  <span class="comment">/**
   * Error: Number to call is invalid
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   *
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_INVALID_NUMBER  = 22;
  <span class="comment">/**
   * Error: No answer from called line.
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   *
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.ERROR_CALL_NOT_ANSWERED  = 23;

  var commPortalErrors = [];
  commPortalErrors[CommPortal.ERROR_UNKNOWN                 ] = <span class="literal">"Unknown error"</span>;

  commPortalErrors[CommPortal.ERROR_LOGIN_WINDOW_BLOCKED    ] = <span class="literal">"Login window blocked"</span>;
  commPortalErrors[CommPortal.ERROR_LOGIN_WINDOW_CLOSED     ] = <span class="literal">"Login window closed"</span>;
  commPortalErrors[CommPortal.ERROR_LOGIN_ERROR             ] = <span class="literal">"Login error"</span>;
  commPortalErrors[CommPortal.ERROR_NOT_LOGGED_IN           ] = <span class="literal">"Not logged in"</span>;

  commPortalErrors[CommPortal.ERROR_SUPPLIED_UID            ] = <span class="literal">"Must not include a UID when adding a contact"</span>;
  commPortalErrors[CommPortal.ERROR_MISSING_UID             ] = <span class="literal">"Need a UID specified when modifying a contact"</span>;

  commPortalErrors[CommPortal.ERROR_NO_CALLLISTS            ] = <span class="literal">"Subscriber does not keep call lists"</span>;

  commPortalErrors[CommPortal.ERROR_MAKE_CALL_ERROR         ] = <span class="literal">"Error when making phone call"</span>;
  commPortalErrors[CommPortal.ERROR_CALL_IN_PROGRESS        ] = <span class="literal">"Another call is already in progress"</span>;
  commPortalErrors[CommPortal.ERROR_NO_CURRENT_CALL         ] = <span class="literal">"There is no current call"</span>;
  commPortalErrors[CommPortal.ERROR_DATA_FETCH_ERROR        ] = <span class="literal">"Error fetching data from server"</span>;
  commPortalErrors[CommPortal.ERROR_DATA_SAVE_ERROR         ] = <span class="literal">"Error saving data to server"</span>;
  commPortalErrors[CommPortal.ERROR_NOT_RAW_DATA            ] = <span class="literal">"Data to be saved must be in raw wire format"</span>;
  commPortalErrors[CommPortal.ERROR_SESSION_STATE_INVALID   ] = <span class="literal">"Session state for reconnection was invalid"</span>;
  commPortalErrors[CommPortal.ERROR_LOGIN_TOKEN_TOO_NEW     ] = <span class="literal">"Token is too new for this version of CommPortal SDK"</span>;
  commPortalErrors[CommPortal.ERROR_SERVER_INVALID_FORMAT   ] = <span class="literal">"Unable to parse the server string"</span>;

  commPortalErrors[CommPortal.ERROR_ACTION_INVALID_DATA     ] = <span class="literal">"Action failed"</span>;

  commPortalErrors[CommPortal.ERROR_NO_CORRESPONDING_HANDLER] = <span class="literal">"No corresponding call handler found"</span>;
  commPortalErrors[CommPortal.ERROR_INCOMPATIBLE_EVENTS     ] = <span class="literal">"Incompatible combination of events"</span>;

  commPortalErrors[CommPortal.ERROR_SUBSCRIPTION_NOT_ALLOWED] = <span class="literal">"Subscription not allowed"</span>;

  commPortalErrors[CommPortal.ERROR_LINE_BUSY               ] = <span class="literal">"The called line is busy"</span>;
  commPortalErrors[CommPortal.ERROR_INVALID_NUMBER          ] = <span class="literal">"The called number is invalid"</span>;
  commPortalErrors[CommPortal.ERROR_CALL_NOT_ANSWERED       ] = <span class="literal">"The called line did not answer"</span>;

  <span class="comment">/**
   * The object type that gets passed back to an error callback.
   *
   * <span class="attrib">@private</span>
   */</span>
  <span class="reserved">function</span> CommPortalError(id, extras)
  {
    <span class="comment">// We always save the id</span>
    <span class="reserved">this</span>.id = id;

    <span class="comment">// Look up a text version of the error based on its id</span>
    <span class="reserved">this</span>.message = commPortalErrors[id in commPortalErrors ? id : CommPortal.ERROR_UNKNOWN];

    <span class="comment">// There may be additional information provided with the error</span>
    <span class="reserved">if</span> (extras)
    {
      <span class="reserved">for</span> (var i in extras)
      {
        <span class="comment">// We only take items that have been defined locally - we don't want</span>
        <span class="comment">// to copy any fields that may have been added to the global</span>
        <span class="comment">// object prototype.</span>
        <span class="reserved">if</span> (extras.hasOwnProperty(i))
        {
          <span class="reserved">this</span>[i] = extras[i];
        }
      }
    }
  }

  <span class="comment">/**
   * Return an (English) text description of the error.
   *
   * <span class="attrib">@private</span>
   */</span>
  CommPortalError.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span>()
  {
    <span class="reserved">return</span> <span class="reserved">this</span>.message;
  };

  <span class="comment">/**
   * Queue up an error response to the error callback
   */</span>
  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> queueError(callback, connection, errorId, extras)
  {
    <span class="reserved">if</span> (callback)
    {
      queueCallback(callback, connection, new CommPortalError(errorId, extras));
    }
  }

  <span class="comment">/**
   * Queue up a response to a callback
   */</span>
  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> queueCallback(callback, connection)
  {
    <span class="reserved">if</span> (callback)
    {
      var args = [];

      <span class="comment">// Copy over any values to pass to the callback.</span>
      <span class="comment">// The connection object is always the first value.</span>
      <span class="reserved">for</span> (var i = 1; i &lt; arguments.length; i++)
      {
        args.push(arguments[i]);
      }

      <span class="comment">// We use a zero length timeout, to ensure this call is always</span>
      <span class="comment">// decoupled from the caller stack frame (ie is always asynchronous)</span>
      setTimeout(<span class="reserved">function</span>()
      {
        callback.apply(null, args);
      }, 0);
    }
  }

  <span class="comment">/**
   * CORE API: Gets the redirect URL.
   *
   * &lt;p&gt;
   * See {<span class="attrib">@link</span> CommPortal#setRedirectUrl} for details on its purpose and
   * valid values.
   * &lt;/p&gt;
   *
   * <span class="attrib">@return</span> {String} the redirect URL
   */</span>
  CommPortal.getRedirectUrl = <span class="reserved">function</span>()
  {
    <span class="reserved">return</span> sRedirectUrl;
  };

  <span class="comment">/**
   * CORE API: Sets the redirect URL.
   *
   * &lt;p&gt;
   * The redirect URL must point to a small file on the same domain as the
   * page.  It is used to work around "same-origin policy" restrictions.  If
   * requests to the URL returns an error (e.g. 404 File not Found), some
   * browsers may not notify the CommPortal SDK that requests have been
   * redirected and it will fail to operate correctly.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * The redirect URL defaults to empty.txt in the same directory as the SDK
   * itself, as long as the SDK is hosted on the same domain as the page.  If
   * the SDK is not hosted on the same domain, it defaults to empty.txt in the
   * same directory as the page.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {String} redirectUrl the redirect URL
   */</span>
  CommPortal.setRedirectUrl = <span class="reserved">function</span>(redirectUrl)
  {
    sRedirectUrl = toAbsoluteUrl(redirectUrl);
  };

  <span class="comment">/**
   * Setter for getRequestCallback. {See {<span class="attrib">@link</span> callbacks#getRequestCallback}}
   * <span class="attrib">@private</span>
   * <span class="attrib">@param</span> {function} callBack callback receiving requested url
   */</span>
  CommPortal.<span class="reserved">prototype</span>.setGetRequestCallback = <span class="reserved">function</span>(callBack)
  {
    <span class="reserved">this</span>.getRequestCallback = callBack;
  };

  <span class="comment">/**
   * Setter for getResponseCallback. {See {<span class="attrib">@link</span> callbacks#getResponseCallback}}
   * <span class="attrib">@private</span>
   * <span class="attrib">@param</span> {function} callBack callback receiving fetched data
   */</span>
  CommPortal.<span class="reserved">prototype</span>.setGetResponseCallback = <span class="reserved">function</span>(callBack)
  {
    <span class="reserved">this</span>.getResponseCallback = callBack;
  };

  <span class="comment">/**
   * Setter for updateRequestCallback. {See {<span class="attrib">@link</span> callbacks#updateRequestCallback}}
   * <span class="attrib">@private</span>
   * <span class="attrib">@param</span> {function} callBack callback receiving update form
   */</span>
  CommPortal.<span class="reserved">prototype</span>.setUpdateRequestCallback = <span class="reserved">function</span>(callBack)
  {
    <span class="reserved">this</span>.updateRequestCallback = callBack;
  };

  <span class="comment">/**
   * Setter for updateResponseCallback. {See {<span class="attrib">@link</span> callbacks#updateResponseCallback}}
   * <span class="attrib">@private</span>
   * <span class="attrib">@param</span> {function} callBack callback receiving url
   */</span>
  CommPortal.<span class="reserved">prototype</span>.setUpdateResponseCallback = <span class="reserved">function</span>(callBack)
  {
    <span class="reserved">this</span>.updateResponseCallback = callBack;
  };

  <span class="comment">/**
   * Setter for clientVersion.
   * <span class="attrib">@param</span> {version} Client version to use.
   */</span>
  CommPortal.<span class="reserved">prototype</span>.setClientVersion = <span class="reserved">function</span>(version)
  {
    <span class="reserved">this</span>.clientVersion = version;
  };

  <span class="comment">/**
   * CORE API: Logs in to CommPortal, thereby establishing a current session.
   *
   * &lt;p&gt;
   * If no authenication details are given, pops up a new frame to do the login.
   * Thus should always be called as a result of user action (click)
   * to prevent this being stopped by a popup blocker.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * As an alternative, authentication details can be provided in the the form
   * of one string, which is treated as a persistent token, or as two strings
   * representing subscriber number and password (insecure as this is).
   * In these cases, login does not cause a popup to appear, and no such
   * restriction on only calling this as a result of user action is necessary.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * The optional appId tells the CommPortal server the name of the
   * application, so that it can both log it and prioritize requests better
   * when under load (if the server in use has prioritization configured).
   * Application ids are limited to 32 characters in length, from the set of
   * capital and lower case letters, digits, and the underscore character.
   * The prefix "MS_" is reserved.
   * &lt;/p&gt;
   *
   * &lt;p&gt;The ability to pass an application id, and to log in using number and
   * password are new in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@see</span> #logout
   *
   * <span class="attrib">@param</span> {String} appId [optional] application id for this application
   * <span class="attrib">@param</span> {function} successCallback callback called when successfully logged in (See {<span class="attrib">@link</span> callbacks#loginCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   * <span class="attrib">@param</span> {String} tokenOrNumber [optional] persistent token to perform a
   *   login without the user needing to reenter their credentials,
   *   or if followed by another optional parameter, the phone number of a
   *   subscriber being authenticated via phone number and password parameters
   * <span class="attrib">@param</span> {String} password [optional] password of subscriber
   */</span>
  CommPortal.<span class="reserved">prototype</span>.login = <span class="reserved">function</span>(appId,
                                        successCallback,
                                        failureCallback,
                                        tokenOrNumber,
                                        password)
  {
    <span class="comment">// Only login to a valid server url.</span>
    <span class="reserved">if</span> (parseServerUrl(<span class="reserved">this</span>.server))
    {
      var windowName = createUniqueId(<span class="literal">"login"</span>);

      <span class="reserved">if</span> (typeof appId != <span class="literal">"string"</span>)
      {
        <span class="comment">// The first parameter is not a string, so we assume that the optional</span>
        <span class="comment">// appId has not been provided, and juggle all the other parameters</span>
        password = tokenOrNumber;
        tokenOrNumber = failureCallback;
        failureCallback = successCallback;
        successCallback = appId;
        appId = undefined;
      }

      <span class="comment">// We check which of the optional parameters were given, to work out which</span>
      <span class="comment">// behaviour is the required one</span>
      <span class="reserved">if</span> (password)
      {
        var number = tokenOrNumber;
        var token = undefined;
      }
      <span class="reserved">else</span> <span class="reserved">if</span> (tokenOrNumber)
      {
        token = tokenOrNumber;
      }

      <span class="comment">// The server to log in to.</span>
      <span class="comment">// this.server will be updated later if login succeeds with a redirect</span>
      var loginServer = <span class="reserved">this</span>.serverLogin;

      <span class="comment">// We need to record whether we logged in using a token or not, since we</span>
      <span class="comment">// must not request a token when we already logged in using a token.</span>
      <span class="reserved">this</span>.usedToken = !!token;

      <span class="reserved">if</span> (tokenOrNumber)
      {
        <span class="comment">// We have authentication details, so try to log in using those</span>

        loginServer = <span class="reserved">this</span>.server;

        <span class="comment">// Create a hidden iframe</span>
        var loginWindow = createiFrame(windowName);

        <span class="comment">// Compute the basic context info specifying the client version</span>
        var contextInfoVal = getSASBasicContextInfo(<span class="reserved">this</span>);

        <span class="comment">// Some fields are common to both types of authenticated login</span>
        var fields =
        {
            version : LOGIN_VERSION,
            redirectTo : sRedirectUrl,
            errorRedirectTo : sRedirectUrl,
            ContextInfo : contextInfoVal
        };

        <span class="reserved">if</span> (appId)
        {
          fields.ApplicationID = appId;
        }

        <span class="comment">// Add the method specific fields</span>
        <span class="reserved">if</span> (token)
        {
          <span class="comment">// Produce the bare token (PAT) needed to log in</span>
          <span class="reserved">if</span> (token.match(/^!CPSDK,/))
          {
            <span class="comment">// Version 1 or later token</span>
            var tokenparts = token.split(/,/);

            <span class="reserved">if</span> (tokenparts[1] == 1)
            {
              <span class="comment">// Version 1 token: !CPSDK,1,server,PAT</span>
              loginServer = patchServerUrl(<span class="reserved">this</span>.server, tokenparts[2]);
              token = tokenparts[3];
            }
            <span class="reserved">else</span>
            {
              <span class="comment">// Unsupported token version - fail login.</span>
              <span class="reserved">if</span> (failureCallback)
              {
                <span class="comment">// Call the error callback asynchronously</span>
                queueError(failureCallback,
                           <span class="reserved">this</span>,
                           CommPortal.ERROR_LOGIN_TOKEN_TOO_NEW);
              }

              <span class="comment">// We hit an error, so need to make sure we don't actually try</span>
              <span class="comment">// and log in</span>
              var skipLogin = true;
            }
          }

          fields.Encrypted = token;
        }
        <span class="reserved">else</span>
        {
          fields.DirectoryNumber = number;
          fields.Password = password;
        }

        <span class="reserved">if</span> (!skipLogin)
        {
          <span class="reserved">if</span> (<span class="reserved">this</span>.useGet)
          {
            <span class="comment">// We are using a GET request to simulate the preferred form submission</span>
            <span class="comment">// so we need all the fields in the url</span>
            var urlFields = encodeFieldsForURL(fields);

            var previousURL = simulateSubmit(loginWindow,
                                             <span class="reserved">this</span>.server + <span class="literal">"/login?"</span> + urlFields);
          }
          <span class="reserved">else</span>
          {
            <span class="comment">// Create a form whose response will be sent to the iframe</span>
            var loginForm = createForm(<span class="literal">"CommPortal_passwordLoginSenderForm"</span>,
                                       loginWindow,
                                       loginServer + <span class="literal">"/login"</span>,
                                       fields);

            <span class="comment">// Submit the form we created</span>
            loginForm.submit();
          }
        }
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// No token means do the redirected login.</span>
        var windowURL = loginServer +
                        <span class="literal">"?redirectTo="</span> + encodeURIComponent(sRedirectUrl) +
                        <span class="literal">"&amp;errorRedirectTo="</span> + encodeURIComponent(sRedirectUrl) +
                        <span class="literal">"&amp;version="</span> + LOGIN_VERSION;

        <span class="reserved">if</span> (appId)
        {
          windowURL += <span class="literal">"&amp;ApplicationID="</span> + appId;
        }

        var loginWindow =
          window.open(windowURL,
                      windowName,
                      <span class="literal">"width=340, height=347, scrollbars=no, resizable=yes, toolbar=no, location=yes, status=no"</span>);
        var previousURL = windowURL;
      }

      <span class="reserved">if</span> (!loginWindow)
      {
        <span class="comment">// We failed to get a popup window, which happens when a popup blocker</span>
        <span class="comment">// prevents the window opening.</span>
        <span class="reserved">if</span> (failureCallback)
        {
          <span class="comment">// Call the error callback asynchronously</span>
          queueError(failureCallback, <span class="reserved">this</span>, CommPortal.ERROR_LOGIN_WINDOW_BLOCK);
        }
        <span class="reserved">else</span>
        {
          alert(<span class="literal">"Login appears to have been blocked by a popup blocker"</span>);
        }
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// Start looking for the response</span>
        pollForResponse(<span class="reserved">this</span>,
                        loginWindow,
                        successCallback,
                        failureCallback,
                        handleLoginURL,
                        previousURL);
      }
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// The server name given did not parse</span>
      queueError(failureCallback,
                 <span class="reserved">this</span>,
                 CommPortal.ERROR_SERVER_INVALID_FORMAT);
    }

    <span class="comment">/**
     * Callback when the login response is available
     */</span>
    <span class="reserved">function</span> handleLoginURL(url, connection, loginWindow, successCallback, failureCallback)
    {
      <span class="comment">// Check if the URL has changed to the redirect URL that we expect.</span>
      <span class="reserved">if</span> (url.substring(0, sRedirectUrl.length) == sRedirectUrl)
      {
        <span class="reserved">if</span> (loginWindow.close)
        {
          <span class="comment">// This is a real window (not an iFrame), so we close it</span>
          loginWindow.close();
        }
        <span class="reserved">else</span>
        {
          <span class="comment">// Remove the iframe and any login form from the DOM</span>
          removeElement(loginWindow);
          removeElement(loginForm);
        }

        <span class="reserved">if</span> (connection.usedToken)
        {
          <span class="comment">// Save the token that was used to login</span>
          connection.token = token;
        }

        <span class="comment">// Have a look at the URL parameters</span>
        var queryParams = parseQueryStringParams(url);

        <span class="reserved">if</span> (queryParams.session)
        {
          <span class="comment">// We got a session ID, login succeeded</span>
          connection.sessionId = queryParams.session;

          <span class="reserved">if</span> (queryParams.redirectDomain)
          {
            <span class="comment">// We got redirected.  Update our records with the new server.</span>
            connection.server = patchServerUrl(connection.server,
                                               queryParams.redirectDomain);
          }

          <span class="reserved">if</span> (queryParams.latestVersion)
          {
            <span class="comment">// The server is reporting its latest supported version to us.</span>
            connection.interfaceVersion = queryParams.latestVersion;
          }
          <span class="reserved">else</span>
          {
            <span class="comment">// The server isn't reporting its latest supported version.  It must</span>
            <span class="comment">// be V7.0 or earlier.  We only support V7.0 and later, so we assume</span>
            <span class="comment">// V7.0.</span>
            connection.interfaceVersion = <span class="literal">"7.0"</span>;
          }

          <span class="reserved">if</span> (successCallback)
          {
            <span class="comment">// Callbacks to be called after we finish retrieving the required</span>
            <span class="comment">// data</span>
            <span class="reserved">function</span> callback()
            {
              connection.callEvent.fetchRequiredData(connection, callback2);
            }
            <span class="reserved">function</span> callback2()
            {
              successCallback(connection, connection.sessionId);
            }

            <span class="comment">// Before we call the success callback we fetch some required data</span>
            <span class="comment">// for the CommPortal events</span>
            connection.commPortalEvent.fetchRequiredData(connection, callback);
          }
        }
        <span class="reserved">else</span>
        {
          <span class="comment">// Something went wrong - we may have some more details supplied via</span>
          <span class="comment">// an error parameter</span>
          var error = queryParams.error;
          var extras = error ? { response : error } : undefined;

          queueError(failureCallback,
                     connection,
                     CommPortal.ERROR_LOGIN_ERROR,
                     extras);
        }
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// The URL changed, but not to the value we were looking for.  Poll</span>
        <span class="comment">// again.</span>
        pollForResponse(connection,
                        loginWindow,
                        successCallback,
                        failureCallback,
                        handleLoginURL,
                        url);

      }
    }
  };

  <span class="comment">/**
   * Parse a server URL into its components:
   *
   * &lt;p&gt;&lt;table&gt;
   * &lt;tr&gt;&lt;td&gt;https:// &lt;td&gt;here.example.org  &lt;td&gt;/default/
   * &lt;tr&gt;&lt;td&gt;{scheme} &lt;td&gt;{server}          &lt;td&gt;{brand}
   * &lt;/table&gt;
   *
   * Note that the server part does not have the slashes in it - but the scheme
   * end with a slash, and the brand begins with one.
   *
   * <span class="attrib">@param</span> {String} url The URL to parse
   * <span class="attrib">@return</span> four-element array [url, scheme, server, brand], or null if url
   *   does not parse into the three components
   * <span class="attrib">@type</span> String[]
   *
   * <span class="attrib">@private</span>
   */</span>
  <span class="reserved">function</span> parseServerUrl(url)
  {
    <span class="comment">// We allow for both http and https</span>
    <span class="reserved">return</span> url.match(/^(https?\:\/\/)([^\/]+)(.*)$/);
  }

  <span class="comment">//CodeForTesting3 -- do not delete this line, it is used for automated testing</span>

  <span class="comment">/**
   * Redirect a server URL to a different server.
   *
   * <span class="attrib">@param</span> {String} url the old server URL
   * <span class="attrib">@param</span> {String} server the new server
   * <span class="attrib">@return</span> the new server URL
   * <span class="attrib">@type</span> String
   *
   * <span class="attrib">@private</span>
   */</span>
  <span class="reserved">function</span> patchServerUrl(url, server)
  {
    <span class="comment">// We replace the &lt;server&gt; in, e.g., https://&lt;server&gt;/default/,</span>
    <span class="comment">// while preserving the same scheme and path.</span>
    var urlparts = parseServerUrl(url);
    <span class="reserved">return</span> urlparts[1] + server + urlparts[3];
  }

  <span class="comment">/**
   * CORE API: Reconnect to an existing session
   * &lt;p&gt;
   * Useful if the client can save the session state locally over a page
   * refresh, since reconnecting to the open session takes less server
   * resources than logging in again.
   * &lt;/p&gt;
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@see</span> #getSessionState
   *
   * <span class="attrib">@param</span> {String} sessionState
   *   session state that was previously valid
   * <span class="attrib">@param</span> {function} successCallback
   *   callback called if session is valid (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback
   *   callback called if session is invalid (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.reconnect = <span class="reserved">function</span>(sessionState, successCallback, failureCallback)
  {
    <span class="comment">// Ensure we start from a clean cache state</span>
    <span class="reserved">this</span>.invalidateCache();

    <span class="reserved">if</span> (sessionState)
    {
      <span class="reserved">if</span> (sessionState.indexOf(<span class="literal">"|"</span>) != -1)
      {
        <span class="comment">// We have a valid sessionState.</span>
        var parts = sessionState.split(<span class="literal">"|"</span>);

        <span class="reserved">if</span> (parts.length == 3 &amp;&amp; parseServerUrl(<span class="reserved">this</span>.originalServer))
        {
          <span class="comment">// The session state holds three pieces of information:</span>
          <span class="comment">// - the server (this is presumably a federated server setup)</span>
          <span class="comment">// - the session id</span>
          <span class="comment">// - the interface version.</span>
          <span class="comment">//</span>
          <span class="comment">// Impersonate the given server, session and interface version.</span>
          <span class="reserved">this</span>.server = patchServerUrl(<span class="reserved">this</span>.originalServer, parts[0]);
          <span class="reserved">this</span>.sessionId = parts[1];
          <span class="reserved">this</span>.interfaceVersion = parts[2];
        }
        <span class="reserved">else</span> <span class="reserved">if</span> (parts.length == 2)
        {
          <span class="comment">// The session state holds two pieces of information:</span>
          <span class="comment">// - the session id</span>
          <span class="comment">// - the interface version.</span>
          <span class="comment">//</span>
          <span class="comment">// Impersonate the session and interface version.</span>
          <span class="reserved">this</span>.sessionId = parts[0];
          <span class="reserved">this</span>.interfaceVersion = parts[1];
        }
        <span class="reserved">else</span>
        {
          <span class="comment">// The session state was not in the format we expected, or does not</span>
          <span class="comment">// make sense with the server passed to the constructor, so flag to</span>
          <span class="comment">// return an error</span>
          sessionState = null;
        }
      }
      <span class="reserved">else</span>
      {

        <span class="comment">// The session state was not in the format we expected (it should have</span>
        <span class="comment">// had at least one '|' in it), so flag to return an error.</span>
        sessionState = null;
      }

      <span class="reserved">if</span> (sessionState)
      {
        <span class="comment">// We call on to fetchSubscriberNumber, which will validate whether the</span>
        <span class="comment">// sessionId we are impersonating is indeed valid</span>
        <span class="reserved">this</span>.fetchSubscriberNumber(reconnected, reconnectFailed);
      }
    }

    <span class="reserved">if</span> (!sessionState)
    {
      <span class="comment">// Call the error callback asynchronously</span>
      queueError(failureCallback,
                 <span class="reserved">this</span>,
                 CommPortal.ERROR_SESSION_STATE_INVALID);
    }

    <span class="reserved">function</span> reconnected(connection)
    {
      successCallback(connection);
    }

    <span class="reserved">function</span> reconnectFailed(connection)
    {
      <span class="comment">// Undo the impersonation</span>
      <span class="reserved">this</span>.server = <span class="reserved">this</span>.originalServer;
      <span class="reserved">if</span> (<span class="reserved">this</span>.sessionId)
      {
        delete <span class="reserved">this</span>.sessionId;
      }

      <span class="comment">// Call the error callback asynchronously</span>
      queueError(failureCallback,
                 <span class="reserved">this</span>,
                 CommPortal.ERROR_SESSION_STATE_INVALID);
    }
  };

  <span class="comment">/**
   * CORE API: Synchronous call to return the current session id string.
   * &lt;p&gt;
   * The session id may be helpful if you are trying to manually form
   * urls outside of the SDK, but otherwise is of little use.
   * &lt;/p&gt;
   *
   * <span class="attrib">@return</span> the session id string, or undefined if this object does not
   *   represent a valid, logged in session
   * <span class="attrib">@type</span> String
   *
   * <span class="attrib">@see</span> #login
   * <span class="attrib">@see</span> #getSessionState
   */</span>
  CommPortal.<span class="reserved">prototype</span>.getSessionId = <span class="reserved">function</span>()
  {
    <span class="reserved">return</span> <span class="reserved">this</span>.sessionId;
  };

  <span class="comment">/**
   * CORE API: Synchronous call to return the current session state string.
   * &lt;p&gt;
   * The session state may be passed back in to {<span class="attrib">@link</span> #reconnect}.
   * &lt;/p&gt;
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@return</span> the session state string, or undefined if this object does not
   *   represent a valid, logged in session
   * <span class="attrib">@type</span> String
   *
   * <span class="attrib">@see</span> #reconnect
   * <span class="attrib">@see</span> #getSessionId
   */</span>
  CommPortal.<span class="reserved">prototype</span>.getSessionState = <span class="reserved">function</span>()
  {
    <span class="comment">// The sessionState is undefined unless we have a session ID.</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.sessionId)
    {
      <span class="comment">// The session state is at least the session ID and the interface</span>
      <span class="comment">// version, but may also have the server name prepended below.</span>
      var sessionState = <span class="reserved">this</span>.sessionId + <span class="literal">"|"</span> + <span class="reserved">this</span>.interfaceVersion;

      var server = (parseServerUrl(<span class="reserved">this</span>.server))[2];
      var originalServer = (parseServerUrl(<span class="reserved">this</span>.originalServer))[2];

      <span class="reserved">if</span> (server != originalServer)
      {
        <span class="comment">// The session state also needs to have the server prepended</span>
        sessionState = server + <span class="literal">"|"</span> + sessionState;
      }
    }

    <span class="reserved">return</span> sessionState;
  };

  <span class="comment">/**
   * CORE API: Synchronous call to return the current call id string.
   *
   * <span class="attrib">@return</span> the call id string, or undefined if there is no call currently
   *   in progress on this connection
   * <span class="attrib">@type</span> String
   *
   * <span class="attrib">@see</span> #makeCall
   */</span>
  CommPortal.<span class="reserved">prototype</span>.getCallId = <span class="reserved">function</span>()
  {
    <span class="reserved">return</span> <span class="reserved">this</span>.callId;
  };

  <span class="comment">/**
   * CORE API: Logs out of the current session.
   *
   * <span class="attrib">@see</span> #login
   */</span>
  CommPortal.<span class="reserved">prototype</span>.logout = <span class="reserved">function</span>()
  {
    <span class="comment">// Logout can be achived simply by doing a get to the logout servlet</span>
    var img = new Image();
    img.src = <span class="reserved">this</span>.server + <span class="literal">"/session"</span> + <span class="reserved">this</span>.sessionId + <span class="literal">"/logout"</span>;

    <span class="comment">// We are logged out, so delete the session id</span>
    delete <span class="reserved">this</span>.sessionId;

    <span class="comment">// Discard any data we may have cached</span>
    <span class="reserved">this</span>.invalidateCache();
  };

  <span class="comment">/**
   * Gets access to the authentication token for the current logged in
   * session.
   * &lt;p&gt;
   * The token is passed asynchronously to the provided callback when
   * it is ready.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback called when token arrives (See {<span class="attrib">@link</span> callbacks#tokenCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchToken = <span class="reserved">function</span>(successCallback, failureCallback)
  {
    var connection = <span class="reserved">this</span>;

    <span class="reserved">if</span> (<span class="reserved">this</span>.sessionId)
    {
      <span class="reserved">if</span> (<span class="reserved">this</span>.token)
      {
        <span class="comment">// We already have a token, so return that.  The token could have</span>
        <span class="comment">// come from a previous call to fetchToken, or it could have come from</span>
        <span class="comment">// the fact that we logged in using a token, in which case we cannot</span>
        <span class="comment">// get another token - so must return the one we originally used.</span>
        returnToken();
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// Create a uniquely named callback function for this request.</span>
        var callbackName = createUniqueId(<span class="literal">"callback"</span>);
        var callback = <span class="literal">"CommPortal."</span> + callbackName;

        <span class="comment">// Register the uniquely-named callback</span>
        CommPortal[callbackName] = <span class="reserved">function</span>(structure)
        {
          try
          {
            <span class="comment">// Save the token</span>
            connection.token = structure.Encrypted;

            returnToken();
          }
          finally
          {
            <span class="comment">// Remove the now unneeded script tag.</span>
            removeElement(scriptTag);

            <span class="comment">// This callback is now finished with, get rid of it.</span>
            delete CommPortal[callbackName];
          }
        };

        <span class="comment">// Calculate the CommPortal token URL</span>
        var url = <span class="reserved">this</span>.server +
                  <span class="literal">"/session"</span> +
                  <span class="reserved">this</span>.sessionId +
                  <span class="literal">"/line/token?Password=*"</span> +
                  <span class="literal">"&amp;callback="</span> + callback +
                  <span class="literal">"&amp;version="</span> + <span class="reserved">this</span>.interfaceVersion;

        <span class="comment">// Add a new script tag with that URL.  Once loaded, it will kick off our</span>
        <span class="comment">// callback.</span>
        var scriptTag = appendScriptTag(url);
      }
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// Queue a callback, so that it is never called synchronously</span>
      queueError(failureCallback,
                 connection,
                 CommPortal.ERROR_NOT_LOGGED_IN);
    }

    <span class="reserved">function</span> returnToken()
    {
      <span class="comment">// Calculate the token to return.  As well as the PAT itself, this also</span>
      <span class="comment">// contains the server that issued it (since we may have been redirected</span>
      <span class="comment">// on login).</span>
      <span class="comment">//</span>
      <span class="comment">// Token formats:</span>
      <span class="comment">//</span>
      <span class="comment">// Version 0:   PAT</span>
      <span class="comment">// Version 1:   !CPSDK,1,server,PAT</span>
      <span class="comment">//</span>
      var fullToken = <span class="literal">"!CPSDK,1,"</span> +
                      parseServerUrl(connection.server)[2] + <span class="literal">","</span> +
                      connection.token;

      queueCallback(successCallback,
                    connection,
                    fullToken);
    }
  };

  <span class="comment">/**
   * CORE API: Fetches data from the CommPortal server via the JSON interface.
   *
   * &lt;p&gt;
   * The data passed to the successCallback is a flattened and cleaned up
   * version of the data received over the wire.
   * &lt;/p&gt;
   * &lt;p&gt;
   * Where multiple pieces of data are being fetched, one callback is called
   * for each piece of data.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {String/String[]} dataTypes which data should be fetched.
   *   Can consist of a single value, or an array of such values.
   * <span class="attrib">@param</span> {function} successCallback callback called for each item of data
   *   successfully fetched (See {<span class="attrib">@link</span> callbacks#fetchCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called for each error that occurs
   *
   * <span class="attrib">@see</span> #fetchRawData
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchData = <span class="reserved">function</span>(dataTypes,
                                            successCallback,
                                            failureCallback)
  {
    <span class="reserved">return</span> innerFetchData(<span class="reserved">this</span>,
                          dataTypes,
                          successCallback,
                          failureCallback);
  };
  <span class="comment">/**
   * CORE API: Fetches raw data from the CommPortal server via the JSON interface.
   *
   * &lt;p&gt;
   * The data passed to the successCallback is exactly as received over the
   * wire, and as such is suitable for passing back in to the saveData method.
   * &lt;/p&gt;
   * &lt;p&gt;
   * Where multiple pieces of data are being fetched, one callback is called
   * for each piece of data.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {String/String[]} dataTypes which data should be fetched.
   *   Can consist of a single value, or an array of such values.
   * <span class="attrib">@param</span> {function} successCallback callback called for each item of data
   *   successfully fetched (See {<span class="attrib">@link</span> callbacks#fetchCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called for each error that occurs
   *
   * <span class="attrib">@see</span> #fetchData
   * <span class="attrib">@see</span> #saveData
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchRawData = <span class="reserved">function</span>(dataTypes,
                                               successCallback,
                                               failureCallback)
  {
    <span class="reserved">return</span> innerFetchData(<span class="reserved">this</span>,
                          dataTypes,
                          true,
                          successCallback,
                          failureCallback);
  };

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> innerFetchData(connection,
                          dataTypes,
                          returnRaw,
                          successCallback,
                          failureCallback)
  {
    <span class="comment">// Process the parameters</span>
    <span class="reserved">if</span> (typeof returnRaw == <span class="literal">"function"</span>)
    {
      <span class="comment">// The optional returnRaw parameter was omitted, so shuffle the other</span>
      <span class="comment">// parameters around</span>
      failureCallback = successCallback;
      successCallback = returnRaw;
      returnRaw = false;
    }

    <span class="reserved">if</span> (connection.sessionId)
    {
      <span class="comment">// Create a uniquely named callback function for this request.</span>
      var callbackName = createUniqueId(<span class="literal">"callback"</span>);
      var callback = <span class="literal">"CommPortal."</span> + callbackName;

      <span class="reserved">if</span> (typeof dataTypes != <span class="literal">"object"</span>)
      {
        dataTypes = [dataTypes];
      }

      <span class="comment">// Register the uniquely-named callback. The parameters are part of the</span>
      <span class="comment">// CommPortal JSON interface.</span>
      CommPortal[callbackName] = <span class="reserved">function</span>(objectIdentity,
                                          dataType,
                                          getData,
                                          getErrors,
                                          updateData,
                                          updateErrors)
      {
        <span class="comment">// Call the getReponseCallback function if it is set.</span>
        <span class="reserved">if</span> (connection.getResponseCallback)
        {
          connection.getResponseCallback(callbackName,
                                         objectIdentity,
                                         dataType,
                                         getData,
                                         getErrors,
                                         updateData,
                                         updateErrors);
        }

        <span class="comment">// Wrap the callbacks in a try block, to protect against badly written</span>
        <span class="comment">// callback functions.</span>
        try
        {
          <span class="reserved">if</span> (!getErrors)
          {
            <span class="reserved">if</span> (successCallback)
            {
              <span class="reserved">if</span> (returnRaw)
              {
                <span class="comment">// The callback requires raw data</span>
                var data = getData;
              }
              <span class="reserved">else</span>
              {
                <span class="comment">// Convert the RAW JSON style data into a flatter version</span>
                var data = flattenDataObject(getData, dataType);

                <span class="comment">// There may be some other special casing we need to do</span>
                data = handleSpecialCases(dataType, data);

                <span class="comment">// Mark this as processed data, so that we can recognise it if</span>
                <span class="comment">// it is passed back into saveData</span>
                data._cleaned = true;
              }

              queueCallback(successCallback,
                            connection,
                            dataType,
                            data,
                            objectIdentity);
            }
          }
          <span class="reserved">else</span>
          {
            <span class="comment">// TODO Check error type and mark connection as failed if sessionExpired, etc.</span>
            queueError(failureCallback,
                       connection,
                       CommPortal.ERROR_DATA_FETCH_ERROR,
                       { dataType : dataType,
                         errors : getErrors,
                         objectIdentity : objectIdentity });
          }
        }
        finally
        {
          <span class="reserved">if</span> (--CommPortal[callbackName].count === 0)
          {
            <span class="comment">// Remove the now unneeded script tags.</span>
            <span class="reserved">for</span> (var i = 0; i &lt; scriptTags.length; i++)
            {
              removeElement(scriptTags[i]);
            }

            <span class="comment">// This callback is now finished with, get rid of it.</span>
            delete CommPortal[callbackName];
          }
        }
      };
      CommPortal[callbackName].count = dataTypes.length;

      <span class="comment">// If too many data objects are requested at once, the URL will be too</span>
      <span class="comment">// long.  Thus we split large requests up into multiple requests.</span>
      var scriptTags = [];
      var remainingTypes = dataTypes.join(<span class="literal">","</span>);
      var splitSize = 1000;
      <span class="reserved">while</span> (remainingTypes)
      {
        <span class="reserved">if</span> (remainingTypes.length &gt; splitSize)
        {
          var comma = remainingTypes.indexOf(<span class="literal">","</span>, splitSize);
          <span class="reserved">if</span> (comma == -1)
          {
            comma = remainingTypes.lastIndexOf(<span class="literal">","</span>, splitSize);
          }

          var dataType = remainingTypes.substring(0, comma);
          remainingTypes = remainingTypes.substring(comma + 1);
        }
        <span class="reserved">else</span>
        {
          dataType = remainingTypes;
          remainingTypes = <span class="literal">""</span>;
        }

        <span class="comment">// Calculate the CommPortal data URL</span>
        var url = connection.server +
                  <span class="literal">"/session"</span> +
                  connection.sessionId +
                  <span class="literal">"/data?data="</span> + encodeURIComponent(dataType) +
                  <span class="literal">"&amp;callback="</span> + callback +
                  <span class="literal">"&amp;version="</span> + connection.interfaceVersion;

        <span class="comment">// Add a new script tag with that URL.  Once loaded, it will kick off our</span>
        <span class="comment">// callback.</span>
        <span class="comment">//</span>
        <span class="comment">// TODO Start a timeout timer to detect connection failure.</span>
        scriptTags.push(appendScriptTag(url));

        <span class="comment">// Call the getRequestCallback function if it is set.</span>
        <span class="reserved">if</span> (connection.getRequestCallback)
        {
          connection.getRequestCallback(url);
        }
      }
    }
    <span class="reserved">else</span>
    {
      queueError(failureCallback,
                 connection,
                 CommPortal.ERROR_NOT_LOGGED_IN);
    }
  }

  <span class="comment">/**
   * Gets the logged in subscriber's phone number.
   * &lt;p&gt;
   * The number is passed asynchronously to the provided callback when ready.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback called to pass the number (See {<span class="attrib">@link</span> callbacks#numberCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchSubscriberNumber = <span class="reserved">function</span>(successCallback,
                                                        failureCallback)
  {
    var connection = <span class="reserved">this</span>;

    <span class="reserved">if</span> (<span class="reserved">this</span>.cache.session)
    {
      returnCachedData();
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// We must query the session data</span>
      <span class="reserved">this</span>.fetchData(<span class="literal">"Session"</span>,
                     processSession,
                     failureCallback);
    }

    <span class="reserved">function</span> processSession(connection, dataType, getData, objectIdentity)
    {
      <span class="comment">// Cache the data</span>
      connection.cache.session = getData;

      <span class="comment">// Fix up the COS and DN in the commPortalEvent, so that tracking of call</span>
      <span class="comment">// events (in addEventList and getEventCallback) works correctly for </span>
      <span class="comment">// reconnects.</span>
      connection.callEvent.classOfService = connection.cache.cos;
      <span class="reserved">if</span> (connection.cache.session.ManagedSubscribers[0])
      {
        connection.callEvent.defaultLine =
          connection.cache.session.ManagedSubscribers[0].DirectoryNumber;
      }

      <span class="comment">// Make the callback now</span>
      returnCachedData();
    }

    <span class="reserved">function</span> returnCachedData()
    {
      queueCallback(successCallback,
                    connection,
                    connection.cache.session.ManagedSubscribers[0].DirectoryNumber);
    }
  };

  <span class="comment">/**
   * Gets the logged in subscriber's name.
   * &lt;p&gt;
   * The name is passed asynchronously to the provided callback when ready.
   * &lt;/p&gt;
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback called to pass the number (See {<span class="attrib">@link</span> callbacks#nameCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchSubscriberName = <span class="reserved">function</span>(successCallback,
                                                      failureCallback)
  {
    var connection = <span class="reserved">this</span>;

    <span class="reserved">if</span> (<span class="reserved">this</span>.cache.subscriberName)
    {
      <span class="comment">// We already have the subscriber name cached. Just return the name</span>
      <span class="comment">// from the cache.</span>
      returnCachedName();
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (compareVersion(<span class="reserved">this</span>.interfaceVersion, <span class="literal">"7.3"</span>) &gt;= 0)
    {
      <span class="comment">// Our version is at least 7.3.</span>
      <span class="comment">// Get the name from the Msrb_Subscriber_BaseInformation indication</span>
      <span class="comment">// added in V7.3. This should return data for both EAS-only subscribers</span>
      <span class="comment">// and subscribers on both a CFS and EAS.</span>
      <span class="reserved">this</span>.fetchData(<span class="literal">"Msrb_Subscriber_BaseInformation"</span>,
                     processSubscriberName,
                     failureCallback);
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// Get the name from</span>
      <span class="comment">// Meta_Subscriber_MetaSphere_SubscriberSettings. This should return data</span>
      <span class="comment">// for both EAS-only subscribers and subscribers on both a CFS and EAS.</span>
      <span class="reserved">this</span>.fetchData(<span class="literal">"Meta_Subscriber_MetaSphere_SubscriberSettings"</span>,
                     processSubscriberName,
                     failureCallback);
    }

    <span class="reserved">function</span> processSubscriberName(connection, dataType, getData, objectIdentity)
    {
      <span class="comment">// Cache the name.</span>
      <span class="reserved">if</span> (dataType == <span class="literal">"Meta_Subscriber_MetaSphere_SubscriberSettings"</span>)
      {
        connection.cache.subscriberName = getData.DisplayName;
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// We got the Msrb_Subscriber_BaseInformation data.</span>
        connection.cache.subscriberName = getData.SubscriberName;
      }

      <span class="comment">// Return the cached name on our success callback.</span>
      returnCachedName();
    }

    <span class="reserved">function</span> returnCachedName()
    {
      queueCallback(successCallback,
                    connection,
                    connection.cache.subscriberName);
    }
  };

  <span class="comment">/**
   * Gets the count of voicemails.
   * &lt;p&gt;
   * The count is passed asynchronously to the provided callback when ready.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback called to pass the counts (See {<span class="attrib">@link</span> callbacks#countsCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #fetchVoicemails
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchVoicemailCount = <span class="reserved">function</span>(successCallback,
                                                      failureCallback)
  {
    <span class="comment">// Although the protocol contains a messages count, that includes messages</span>
    <span class="comment">// other than voicemails.  Thus to get a true count, we need to call the</span>
    <span class="comment">// method that really fetches the full list, and then count the items in</span>
    <span class="comment">// that.  We trust that caching will make this as efficient as it can.</span>
    <span class="reserved">this</span>.fetchVoicemails(countVoicemails,
                         failureCallback);

    <span class="reserved">function</span> countVoicemails(connection, voicemails)
    {
      var total = voicemails.length;
      var unheard = total;

      <span class="reserved">for</span> (var i = 0; i &lt; total; i++)
      {
        <span class="reserved">if</span> (voicemails[i].Read)
        {
          unheard--;
        }
      }

      successCallback(connection, total, unheard);
    }
  };

  <span class="comment">/**
   * Gets access to the CommPortal voicemails, in an easily accessed simple
   * array format.
   * &lt;p&gt;
   * The voicemails are passed asynchronously to the provided callback when
   * they are ready.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback called to pass the voicemails (See {<span class="attrib">@link</span> callbacks#voicemailsCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   * <span class="attrib">@param</span> {String/String[]} (optional) a single codec or an array of codecs which the caller can handle. If not provided this will be assume to be g711u.
   *
   * <span class="attrib">@see</span> #fetchVoicemailCount
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchVoicemails = <span class="reserved">function</span>(successCallback,
                                                  failureCallback,
                                                  codecs)
  {
    var connection = <span class="reserved">this</span>;
    
    <span class="reserved">if</span> (<span class="reserved">this</span>.cache.voicemails)
    {
      returnCachedData();
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// We must query the voicemails</span>
      <span class="reserved">this</span>.fetchData(<span class="literal">"Meta_Subscriber_MetaSphere_VoicemailMessages"</span>,
                     processVoicemails,
                     failureCallback);
    }

    <span class="reserved">function</span> processVoicemails(connection, dataType, getData, objectIdentity)
    {
      <span class="comment">// We return a simple array, of simple objects</span>
      var voicemails = [];

      <span class="reserved">for</span> (var i = 0; i &lt; getData.length; i++)
      {
        var message = getData[i];

        <span class="reserved">if</span> (message.ReportType || message.SystemMessageType)
        {
          <span class="comment">// It's a system message or a report message - ignore it</span>
        }
        <span class="reserved">else</span>
        {
          voicemails.push(message);
        }
      }

      connection.cache.voicemails = voicemails;

      returnCachedData();
    }

    <span class="reserved">function</span> returnCachedData()
    {
      <span class="reserved">for</span> (var i = 0; i &lt; connection.cache.voicemails.length; i++)
      {        
        var message = connection.cache.voicemails[i];

        <span class="comment">// Add a field that gives the URL to get the audio file from</span>
        message.AudioFile =
          connection.server + <span class="literal">"/session"</span> + connection.sessionId + <span class="literal">"/line/"</span> +
          <span class="literal">"voicemail.fetch?id="</span> + message.Id +
          <span class="literal">"&amp;version="</span> + connection.interfaceVersion + 
          <span class="literal">"&amp;codec="</span> + codecReqStr(codecs);
      }
    
      queueCallback(successCallback,
                    connection,
                    connection.cache.voicemails);
    }
  };
  
  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> codecReqStr(codecs)
  {
    var codecStr = <span class="literal">""</span>;

    <span class="reserved">if</span> (typeof codecs !== <span class="literal">'undefined'</span>)
    {
      <span class="comment">// We may have been passed a single codec - treat it as if we were given a</span>
      <span class="comment">// single entry array</span>
      <span class="reserved">if</span> (typeof codecs != <span class="literal">"object"</span>)
      {
        codecs = [codecs];
      }

      <span class="reserved">for</span> (var i = 0; i &lt; codecs.length; i++)
      {
        codecStr += codecs[i];
        <span class="reserved">if</span> (i &lt; (codecs.length - 1))
        {
          codecStr += <span class="literal">";"</span>;
        }
      }
    }
    
    <span class="reserved">return</span> codecStr;
  }

  <span class="comment">/**
   * Gets the count of faxes.
   * &lt;p&gt;
   * The count is passed asynchronously to the provided callback when ready.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback called to pass the counts (See {<span class="attrib">@link</span> callbacks#countsCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #fetchFaxes
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchFaxCount = <span class="reserved">function</span>(successCallback,
                                                failureCallback)
  {
    <span class="comment">// Although the protocol contains a messages count, that includes messages</span>
    <span class="comment">// other than faxes.  Thus to get a true count, we need to call the</span>
    <span class="comment">// method that really fetches the full list, and then count the items in</span>
    <span class="comment">// that.  We trust that caching will make this as efficient as it can.</span>
    <span class="reserved">this</span>.fetchFaxes(countFaxes,
                    failureCallback);

    <span class="reserved">function</span> countFaxes(connection, faxes)
    {
      var total = faxes.length;
      var unheard = total;

      <span class="reserved">for</span> (var i = 0; i &lt; total; i++)
      {
        <span class="reserved">if</span> (faxes[i].Read)
        {
          unheard--;
        }
      }

      successCallback(connection, total, unheard);
    }
  };

  <span class="comment">/**
   * Gets access to the CommPortal faxes, in an easily accessed simple
   * array format.
   * &lt;p&gt;
   * The faxes are passed asynchronously to the provided callback when
   * they are ready.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback called to pass the faxes (See {<span class="attrib">@link</span> callbacks#faxesCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #fetchFaxCount
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchFaxes = <span class="reserved">function</span>(successCallback,
                                             failureCallback)
  {
    var connection = <span class="reserved">this</span>;

    <span class="reserved">if</span> (<span class="reserved">this</span>.cache.faxes)
    {
      returnCachedData();
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// We must query the faxes</span>
      <span class="reserved">this</span>.fetchData(<span class="literal">"Meta_Subscriber_MetaSphere_FaxMessages"</span>,
                     processFaxes,
                     failureCallback);
    }

    <span class="reserved">function</span> processFaxes(connection, dataType, getData, objectIdentity)
    {
      <span class="comment">// We return a simple array, of simple objects</span>
      var faxes = [];

      <span class="reserved">for</span> (var i = 0; i &lt; getData.length; i++)
      {
        var message = getData[i];

        <span class="reserved">if</span> (message.ReportType || message.SystemMessageType)
        {
          <span class="comment">// It's a system message or a report message - ignore it</span>
        }
        <span class="reserved">else</span>
        {
          faxes.push(message);

          <span class="comment">// Add a field that gives the URL to get the TIFF file from</span>
          message.ImageFile =
            connection.server + <span class="literal">"/session"</span> + connection.sessionId + <span class="literal">"/line/"</span> +
            <span class="literal">"fax.tif?id="</span> + message.Id +
            <span class="literal">"&amp;version="</span> + connection.interfaceVersion;
          <span class="comment">// Add a field that gives the URL to get the PDF file from</span>
          message.ImageFilePDF = message.ImageFile.replace(<span class="literal">"fax.tif?id="</span>,
                                                           <span class="literal">"fax.pdf?id="</span>);
        }
      }

      connection.cache.faxes = faxes;

      returnCachedData();
    }

    <span class="reserved">function</span> returnCachedData()
    {
      queueCallback(successCallback,
                    connection,
                    connection.cache.faxes);
    }
  };


  <span class="comment">/**
   * Converts a string format date, as contained in a
   * {<span class="attrib">@link</span> voicemail}, {<span class="attrib">@link</span> fax}, or {<span class="attrib">@link</span> call}
   * entry into a JavaScript Date object.
   *
   * <span class="attrib">@param</span> {String} dateString date as a string
   *
   * <span class="attrib">@return</span> the date as a JavaScript Date object
   * <span class="attrib">@type</span> Date
   */</span>
  CommPortal.<span class="reserved">prototype</span>.convertDate = <span class="reserved">function</span>(dateString)
  {
    <span class="comment">// Split the string into individual fields</span>
    var fields = dateString.split(/[. :]/);

    <span class="comment">// There are a number of formats we need to handle</span>
    <span class="comment">//  YYYY.MM.DD hh.mm.ss   - (all numeric) used by voicemails</span>
    <span class="comment">//  DD mth YY hh:mm:ss    - where mth is alphabetic, used by call lists</span>
    <span class="reserved">if</span> (isNaN(parseInt(fields[1], 10)))
    {
      <span class="comment">// The month is non numeric</span>
      var day = parseInt(fields[0], 10);
      var year = 2000 + parseInt(fields[2], 10);

      <span class="comment">// The month names are always in English</span>
      var month = <span class="literal">"JanFebMarAprMayJunJulAugSepOctNovDec"</span>.indexOf(fields[1]) / 3;
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// We assume everything is numeric</span>
      var year = parseInt(fields[0], 10);
      var month = parseInt(fields[1], 10) - 1;
      var day = parseInt(fields[2], 10);
    }

    var date = new Date(year,
                        month,
                        day,
                        parseInt(fields[3], 10),
                        parseInt(fields[4], 10),
                        parseInt(fields[5], 10));
    <span class="reserved">return</span> date;
  };

  <span class="comment">/**
   * Marks one or a number of voicemails as heard.
   *
   * <span class="attrib">@param</span> {String/String[]} voicemailIds single id as string, or array of ids
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #markVoicemailsAsUnheard
   * <span class="attrib">@see</span> #confirmVoicemailsHeard
   */</span>
  CommPortal.<span class="reserved">prototype</span>.markVoicemailsAsHeard = <span class="reserved">function</span>(voicemailIds,
                                                        successCallback,
                                                        failureCallback)
  {
    handleMessageAction(<span class="reserved">this</span>,
                        voicemailIds,
                        successCallback,
                        failureCallback,
                        <span class="literal">"MessagesToMarkAsRead"</span>);
  };

  <span class="comment">/**
   * Marks one or a number of voicemails as unheard.
   *
   * <span class="attrib">@param</span> {String/String[]} voicemailIds single id as string, or array of ids
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #markVoicemailsAsHeard
   */</span>
  CommPortal.<span class="reserved">prototype</span>.markVoicemailsAsUnheard = <span class="reserved">function</span>(voicemailIds,
                                                          successCallback,
                                                          failureCallback)
  {
    handleMessageAction(<span class="reserved">this</span>,
                        voicemailIds,
                        successCallback,
                        failureCallback,
                        <span class="literal">"MessagesToMarkAsUnread"</span>);
  };

  <span class="comment">/**
   * Deletes one or a number of voicemails.
   *
   * <span class="attrib">@param</span> {String/String[]} voicemailIds single id as string, or array of ids
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.deleteVoicemails = <span class="reserved">function</span>(voicemailIds,
                                                   successCallback,
                                                   failureCallback)
  {
    handleMessageAction(<span class="reserved">this</span>,
                        voicemailIds,
                        successCallback,
                        failureCallback,
                        <span class="literal">"MessagesToDelete"</span>);
  };

  <span class="comment">/**
   * A synchronous call (no callbacks) that indicates that the passed voicemails
   * have (probably) been heard, without making an explicit call to the
   * server to set this state.  Allows the API to keep its state in sync.
   *
   * &lt;p&gt;
   * Should be called whenever the {<span class="attrib">@link</span> voicemail#AudioFile} field has been
   * used to actually fetch the referenced file.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {String/String[]} voicemailIds single id as string, or array of ids
   *
   * <span class="attrib">@see</span> #markVoicemailsAsHeard
   */</span>
  CommPortal.<span class="reserved">prototype</span>.confirmVoicemailsHeard = <span class="reserved">function</span>(voicemailIds)
  {
    <span class="comment">// We don't do anything clever with the passed ids - we simply invalidate</span>
    <span class="comment">// the voicemail related part of the cache.</span>
    delete <span class="reserved">this</span>.cache.voicemails;
  };

  <span class="comment">/**
   * Uploads a voicemail audio file to the CommPortal server.
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {string} formId The ID of the HTML &lt;form&gt; element containing the
   *                        file input to be submitted to the server.
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.uploadVoicemailAudio = <span class="reserved">function</span>(formId,
                                                       successCallback,
                                                       failureCallback)
  {
    uploadAudioFile(<span class="reserved">this</span>, <span class="literal">"voicemail.wav"</span>, <span class="literal">"newvoicemail"</span>,
                    formId, successCallback, failureCallback);
  };

  <span class="comment">/**
   * Send a voicemail using the previously uploaded audio file.
   * See {<span class="attrib">@link</span> commportal#uploadVoicemailAudio} for more details.
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {string} destNumber The number to send the voicemail to.
   * <span class="attrib">@param</span> {boolean} isUrgent Whether the voicemail should be marked urgent.
   * <span class="attrib">@param</span> {boolean} isPrivate Whether the voicemail should be marked private.
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.sendVoicemail = <span class="reserved">function</span>(destNumber,
                                                isUrgent,
                                                isPrivate,
                                                successCallback,
                                                failureCallback)
  {
    <span class="comment">// First we clear the cache of fetched voicemails</span>
    delete <span class="reserved">this</span>.cache.voicemails;

    <span class="comment">// Construct a new voicemail JSON object</span>
    var newVoicemail =
    {
      <span class="literal">"DestinationNumbers"</span>: [
        {<span class="literal">"_"</span> : destNumber}
      ],
      <span class="literal">"Urgent"</span>: {<span class="literal">"_"</span> : isUrgent},
      <span class="literal">"Private"</span>: {<span class="literal">"_"</span> : isPrivate},
      <span class="literal">"MessageType"</span>: {<span class="literal">"_"</span> : <span class="literal">"VOICEMAIL"</span>},
      <span class="literal">"Action"</span>: {<span class="literal">"_"</span> : <span class="literal">"CREATE"</span>},
      <span class="literal">"AudioFileName"</span>: {<span class="literal">"_"</span> : <span class="reserved">this</span>.cache[<span class="literal">"newvoicemail"</span>]}
    };

    <span class="comment">// Send the update to the server</span>
    <span class="reserved">this</span>.saveData(<span class="literal">"Meta_Subscriber_MetaSphere_MessageToSend"</span>,
                   newVoicemail,
                   successCallback,
                   failureCallback);
  };

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> handleMessageAction(connection,
                               messageIds,
                               successCallback,
                               failureCallback,
                               dataType)
  {
    <span class="comment">// We may have been passed a single id - treat it as if we were given a</span>
    <span class="comment">// single entry array</span>
    <span class="reserved">if</span> (typeof messageIds != <span class="literal">"object"</span>)
    {
      messageIds = [messageIds];
    }

    <span class="comment">// Work through the array of messages, forming them in to the wire</span>
    <span class="comment">// protocol array structure</span>
    var data = [];
    <span class="reserved">for</span> (var i = 0; i &lt; messageIds.length; i++)
    {
      <span class="comment">// We make sure the ids are treated as strings, even if they somehow got</span>
      <span class="comment">// changed to be numbers by appending them to an empty string</span>
      data.push({<span class="literal">"_"</span> : <span class="literal">""</span> + messageIds[i]});
    }

    <span class="comment">// We are updating the messages, so invalidate any cached data for them</span>
    <span class="reserved">if</span> (dataType.match(<span class="literal">"Fax"</span>))
    {
      <span class="comment">// We are acting on the fax messages</span>
      delete connection.cache.faxes;
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// We are acting on the voicemails</span>
      delete connection.cache.voicemails;
    }

    <span class="comment">// Send the command to the server</span>
    connection.saveData(dataType,
                        data,
                        successCallback,
                        failureCallback,
                        undefined);
  }

  <span class="comment">/**
   * Marks one or a number of faxes as viewed.
   *
   * <span class="attrib">@param</span> {String/String[]} faxIds single id as string, or array of ids
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #markFaxesAsUnviewed
   * <span class="attrib">@see</span> #confirmFaxesViewed
   */</span>
  CommPortal.<span class="reserved">prototype</span>.markFaxesAsViewed = <span class="reserved">function</span>(faxIds,
                                                    successCallback,
                                                    failureCallback)
  {
    handleMessageAction(<span class="reserved">this</span>,
                        faxIds,
                        successCallback,
                        failureCallback,
                        <span class="literal">"Meta_Subscriber_MetaSphere_FaxMessagesToMarkAsRead"</span>);
  };

  <span class="comment">/**
   * Marks one or a number of faxes as unviewed.
   *
   * <span class="attrib">@param</span> {String/String[]} faxIds single id as string, or array of ids
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #markFaxesAsViewed
   */</span>
  CommPortal.<span class="reserved">prototype</span>.markFaxesAsUnviewed = <span class="reserved">function</span>(faxIds,
                                                      successCallback,
                                                      failureCallback)
  {
    handleMessageAction(<span class="reserved">this</span>,
                        faxIds,
                        successCallback,
                        failureCallback,
                        <span class="literal">"Meta_Subscriber_MetaSphere_FaxMessagesToMarkAsUnread"</span>);
  };

  <span class="comment">/**
   * Deletes one or a number of faxes.
   *
   * <span class="attrib">@param</span> {String/String[]} faxIds single id as string, or array of ids
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.deleteFaxes = <span class="reserved">function</span>(faxIds,
                                              successCallback,
                                              failureCallback)
  {
    handleMessageAction(<span class="reserved">this</span>,
                        faxIds,
                        successCallback,
                        failureCallback,
                        <span class="literal">"Meta_Subscriber_MetaSphere_FaxMessagesToDelete"</span>);
  };

  <span class="comment">/**
   * A synchronous call (no callbacks) that indicates that the passed faxes
   * have (probably) been viewed, without making an explicit call to the
   * server to set this state.  Allows the API to keep its state in sync.
   *
   * &lt;p&gt;
   * Should be called whenever the {<span class="attrib">@link</span> fax#ImageFile} or
   * {<span class="attrib">@link</span> fax#ImageFilePDF} field has been used to actually fetch the
   * referenced file.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {String/String[]} faxIds single id as string, or array of ids
   *
   * <span class="attrib">@see</span> #markFaxesAsViewed
   */</span>
  CommPortal.<span class="reserved">prototype</span>.confirmFaxesViewed = <span class="reserved">function</span>(faxIds)
  {
    <span class="comment">// We don't do anything clever with the passed ids - we simply invalidate</span>
    <span class="comment">// the fax related part of the cache.</span>
    delete <span class="reserved">this</span>.cache.faxes;
  };

  <span class="comment">/**
   * Gets the list of codecs supported by this EAS.
   * &lt;p&gt;
   * The details are passed asynchronously to the provided callback when ready.
   * &lt;/p&gt;
   *
   * &lt;p&gt;New in version 8.1&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback called to pass the codec details (See {<span class="attrib">@link</span> callbacks#greetingsCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchCodecs = <span class="reserved">function</span>(successCallback,
                                              failureCallback)
  {
    var connection = <span class="reserved">this</span>;
        
    <span class="reserved">this</span>.fetchData(<span class="literal">"Meta_Global_MetaSphere_Configuration"</span>,
                   processCodecs,
                   failureCallback);    

    <span class="reserved">function</span> processCodecs(connection, dataType, getData, objectIdentity)
    {
      var codecInfo = [];
      
      <span class="reserved">if</span> (getData.CodecInfo)
      {
        codecInfo = getData.CodecInfo;
      }
      <span class="reserved">else</span>
      {
        var g711uCodec = {};
        g711uCodec.CodecName = <span class="literal">"g711u"</span>;
        g711uCodec.CodecExtension = <span class="literal">"wav"</span>;
        g711uCodec.CodecContentType = <span class="literal">"audio/wav"</span>;
        codecInfo.push(g711uCodec);
      }
      
      queueCallback(successCallback,
                    connection,
                    codecInfo);
    }
  };
  
  <span class="comment">/**
   * Gets details about the subscriber's greetings.
   * &lt;p&gt;
   * The details are passed asynchronously to the provided callback when ready.
   * &lt;/p&gt;
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback called to pass the greetings details (See {<span class="attrib">@link</span> callbacks#greetingsCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   * <span class="attrib">@param</span> {String/String[]} (optional) a single codec or an array of codecs which the caller can handle. If not provided this will be assume to be g711u.
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchGreetings = <span class="reserved">function</span>(successCallback,
                                                 failureCallback,
                                                 codecs)
  {
    var connection = <span class="reserved">this</span>;

    <span class="comment">// We need to fetch both the Greetings data and the CoS for this function</span>

    <span class="reserved">if</span> (<span class="reserved">this</span>.cache.greetings)
    {
      returnCachedData();
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span>.cache.cos)
    {
      <span class="reserved">this</span>.fetchData(<span class="literal">"Meta_Subscriber_MetaSphere_Greetings"</span>,
                     processGreetings,
                     failureCallback);
    }
    <span class="reserved">else</span>
    {
      <span class="reserved">this</span>.fetchData(<span class="literal">"Meta_Subscriber_MetaSphere_ClassOfService"</span>,
                     processClassOfService,
                     failureCallback);

    }

    <span class="comment">// Cache the CoS data</span>
    <span class="reserved">function</span> processClassOfService(connection, dataType, getData, objectIdentity)
    {
      connection.cache.cos = getData;
      connection.fetchData(<span class="literal">"Meta_Subscriber_MetaSphere_Greetings"</span>,
                           processGreetings,
                           failureCallback);
    }

    <span class="comment">// Process and cache the Greetings data</span>
    <span class="reserved">function</span> processGreetings(connection, dataType, getData, objectIdentity)
    {
      var greetings = {};
      greetings.defaultGreetingType = getData.DefaultGreetingType;

      <span class="comment">// We filter the returned GreetingsList against the list of</span>
      <span class="comment">// greetings allowed by the CoS</span>
      var filteredGreetingsList = [];
      var availGreetings = connection.cache.cos.AvailableGreetings.split(<span class="literal">","</span>);

      <span class="reserved">for</span> (var i = 0; i &lt; getData.GreetingsList.length; i++)
      {
        var greeting = getData.GreetingsList[i];
        var greetingIsAvail = false;

        <span class="comment">// Check if current greeting is available</span>
        <span class="reserved">for</span> (var j = 0; j &lt; availGreetings.length; j++)
        {
          <span class="reserved">if</span> (availGreetings[j] == greeting.GreetingType)
          {
            greetingIsAvail = true;
            break;
          }
        }

        <span class="comment">// Only return the greeting if the CoS says it is available</span>
        <span class="reserved">if</span> (greetingIsAvail)
        {
          var greetingCopy =
          {
            availableForDefault: greeting.AvailableForDefault,
            greetingType: greeting.GreetingType,
            isRecorded: greeting.IsRecorded,
            recordable: greeting.Recordable
          };

          filteredGreetingsList.push(greetingCopy);
        }
      }

      greetings.greetingsList = filteredGreetingsList;
      connection.cache.greetings = greetings;
      returnCachedData();
    }

    <span class="reserved">function</span> returnCachedData()
    {
      <span class="reserved">for</span> (var i = 0; i &lt; connection.cache.greetings.greetingsList.length; i++)
      {        
        var greeting = connection.cache.greetings.greetingsList[i];
        
        <span class="comment">// Add a field that gives the URL to get the audio file from</span>
        <span class="reserved">if</span> (greeting.isRecorded)
        {
          greeting.audioFile =
              connection.server + <span class="literal">"/session"</span> + connection.sessionId + <span class="literal">"/line/"</span> +
              <span class="literal">"greeting.fetch?type="</span> + greeting.greetingType +
              <span class="literal">"&amp;version="</span> + connection.interfaceVersion + 
              <span class="literal">"&amp;codec="</span> + codecReqStr(codecs);
        }
      }
    
      queueCallback(successCallback,
                    connection,
                    connection.cache.greetings);
    }
  };

  <span class="comment">/**
   * Uploads a greetings audio file to the CommPortal server.
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {string} formId The ID of the HTML &lt;form&gt; element containing the
   *                        file input to be submitted to the server.
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.uploadGreetingsAudio = <span class="reserved">function</span>(formId,
                                                       successCallback,
                                                       failureCallback)
  {
    uploadAudioFile(<span class="reserved">this</span>, <span class="literal">"greeting.wav"</span>, <span class="literal">"newgreeting"</span>,
                    formId, successCallback, failureCallback);
  };

  <span class="comment">/**
   * Update the audio for a greeting type using a previously uploaded audio
   * file. See {<span class="attrib">@link</span> commportal#uploadGreetingsAudio} for more details.
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {string} type The type of the greeting to update.
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.updateGreetingAudio = <span class="reserved">function</span>(type,
                                                      successCallback,
                                                      failureCallback)
  {
    <span class="comment">// Ensure we have greetings data cached</span>
    var connection = <span class="reserved">this</span>;
    <span class="reserved">if</span> (!<span class="reserved">this</span>.cache.greetings)
    {
      <span class="reserved">this</span>.fetchGreetings(doUpdate, failureCallback);
    }
    <span class="reserved">else</span>
    {
      doUpdate();
    }

    <span class="reserved">function</span> doUpdate()
    {
      <span class="comment">// Extract the current default then delete the cache</span>
      var defType = connection.cache.greetings.defaultGreetingType;
      delete connection.cache.greetings;

      <span class="comment">// Construct a greeting audio update JSON object</span>
      var newGreeting =
      {
        <span class="literal">"GreetingsList"</span>:
        [
          {
            <span class="literal">"GreetingType"</span>: {<span class="literal">"_"</span> : type},
            <span class="literal">"GreetingFilename"</span>: {<span class="literal">"_"</span> : connection.cache[<span class="literal">"newgreeting"</span>]}
          }
        ],
        <span class="literal">"DefaultGreetingType"</span>: {<span class="literal">"_"</span> : defType}
      };

      <span class="comment">// Send the update to the server</span>
      connection.saveData(<span class="literal">"Meta_Subscriber_MetaSphere_Greetings"</span>,
                          newGreeting,
                          successCallback,
                          failureCallback);
    }
  };

  <span class="comment">/**
   * Update which greeting type is currently the default. Some greeting types
   * cannot be set directly as the default and must be enabled through other
   * fields on the Meta_Subscriber_MetaSphere_Greetings indication. This
   * can be done using the {<span class="attrib">@link</span> commportal#saveData} function.
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
   CommPortal.<span class="reserved">prototype</span>.updateDefaultGreeting = <span class="reserved">function</span>(type,
                                                         successCallback,
                                                         failureCallback)
  {
    <span class="comment">// Ensure we have greetings data cached</span>
    var connection = <span class="reserved">this</span>;
    <span class="reserved">if</span> (!<span class="reserved">this</span>.cache.greetings)
    {
      <span class="reserved">this</span>.fetchGreetings(doUpdate, failureCallback);
    }
    <span class="reserved">else</span>
    {
      doUpdate();
    }

    <span class="reserved">function</span> doUpdate()
    {
      <span class="comment">// Extract the current default then delete the cache</span>
      var defType = connection.cache.greetings.defaultGreetingType;
      delete connection.cache.greetings;

      <span class="comment">// Construct a greeting default type update JSON object</span>
      var greetingUpdate =
      {
        <span class="literal">"GreetingsList"</span>:
        [
          {
            <span class="literal">"GreetingType"</span>: {<span class="literal">"_"</span> : defType},
            <span class="literal">"AvailableForDefault"</span>: {<span class="literal">"_"</span> : true}
          }
        ],
        <span class="literal">"DefaultGreetingType"</span>: {<span class="literal">"_"</span> : type}
      };

      <span class="comment">// Send the update to the server</span>
      connection.saveData(<span class="literal">"Meta_Subscriber_MetaSphere_Greetings"</span>,
                          greetingUpdate,
                          successCallback,
                          failureCallback);
    }
  };

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> uploadAudioFile(connection, audioURL, audioSaveName,
                           formId, successCallback, failureCallback)
  {
    <span class="reserved">if</span> (connection.sessionId)
    {
      <span class="comment">// Lookup the supplied form ID</span>
      var formElement = document.getElementById(formId);      
      var formUploadFileExt = <span class="literal">".wav"</span>;
      
      var formUploadFilename = formElement.uploadFile.value;
      <span class="reserved">if</span> (formUploadFilename.lastIndexOf(<span class="literal">'.'</span>) &gt; -1)
      { 
        formUploadFileExt = formUploadFilename.substring(formUploadFilename.lastIndexOf(<span class="literal">'.'</span>));
      }
      var uploadFilename = audioSaveName + formUploadFileExt;

      <span class="comment">// Create a hidden iFrame to hold the response</span>
      var iFrameId = createUniqueId(<span class="literal">"upload"</span>);
      var iFrame = createiFrame(iFrameId);

      var fields =
      {
        version : connection.interfaceVersion,
        redirectTo : sRedirectUrl + <span class="literal">"?success=true"</span>,
        errorRedirectTo : sRedirectUrl + <span class="literal">"?error=updateFailed"</span>,
        filename : uploadFilename
      };
      
      connection.cache[audioSaveName] = uploadFilename;

      <span class="comment">// We need to have the fields defined so far as part of the URL</span>
      var urlFields = encodeFieldsForURL(fields);

      var uploadURL = connection.server + <span class="literal">"/session"</span> +
                      connection.sessionId + <span class="literal">"/line/"</span> +
                      audioURL + <span class="literal">"?"</span> + urlFields;
      formElement.action = uploadURL;
      formElement.target = iFrameId;
      formElement.submit();

      <span class="comment">// Start polling for the response</span>
      pollForResponse(connection,
                      iFrame,
                      successCallback,
                      failureCallback,
                      handleUploadAudioResponse);
    }
    <span class="reserved">else</span>
    {
      queueError(failureCallback, connection, CommPortal.ERROR_NOT_LOGGED_IN);
    }

    <span class="comment">/**
     * Callback when the upload audio response is available
     */</span>
    <span class="reserved">function</span> handleUploadAudioResponse(url,
                                       connection,
                                       iFrame,
                                       successCallback,
                                       failureCallback)
    {
      <span class="comment">// We have finished with the iFrame and form so can remove them from the DOM</span>
      removeElement(iFrame);

      var queryParams = parseQueryStringParams(url);

      <span class="reserved">if</span> (queryParams.success)
      {
        queueCallback(successCallback,
                      connection);
      }
      <span class="reserved">else</span>
      {
        var extras = { error : <span class="literal">"uploadFailed"</span> };

        queueError(failureCallback,
                   connection,
                   CommPortal.ERROR_DATA_SAVE_ERROR,
                   extras);
      }
    }
  };

  <span class="comment">/**
   * Checks whether voicemail transcriptions are allowed for this subscriber.
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback called when successful (See {<span class="attrib">@link</span> callbacks#transcriptsEnabledCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchTranscriptionEnabled = <span class="reserved">function</span>(successCallback,
                                                            failureCallback)
  {
    <span class="reserved">if</span> (<span class="reserved">this</span>.cache.transcriptions) 
    {
      <span class="comment">// Return the already cached settings.</span>
      returnCachedData();
    }
    <span class="reserved">else</span> 
    {
      <span class="reserved">this</span>.fetchData(<span class="literal">"SubscriberTranscriptionSettings"</span>,
                     processTranscriptionSettings,
                     failureCallback);
    }

    <span class="comment">// Cache the transcription settings.</span>
    <span class="reserved">function</span> processTranscriptionSettings(connection, 
                                          dataType,
                                          getData, 
                                          objectIdentity)
    {
      connection.cache.transcriptions = getData.Enabled;
      returnCachedData();
    }

    <span class="reserved">function</span> returnCachedData()
    {
      queueCallback(successCallback,
                    connection,
                    connection.cache.transcriptions);
    }
  };

  <span class="comment">/**
   * CORE API: Updates data on the CommPortal server via the JSON interface.
   *
   * <span class="attrib">@param</span> {String} dataType service indication type as used by JSON interface
   * <span class="attrib">@param</span> {Object} data contents of JSON service indication
   * <span class="attrib">@param</span> {function} successCallback callback called if success
   * (See {<span class="attrib">@link</span> callbacks#successCallback}
   * <span class="attrib">@param</span> {function} failureCallback callback called if error
   * (See {<span class="attrib">@link</span> callbacks#failureCallback}
   * <span class="attrib">@param</span> {Object} objectIdentity [optional] can be used to specify a
   *                          context other than the current subscriber
   * <span class="attrib">@param</span> {String} logText [optional] can be used to specify a
   *                        summary of the update being performed which will be
   *                        logged to your Service Assurance Server
   *                        (if this is present and enabled).
   *                        WARNING.  Supplying a logText parameter to this
   *                        function places additional load on the Service
   *                        Assurance Server and should only be called if
   *                        you are sure that your Service Assurance Server
   *                        has sufficient capacity.
   *
   * <span class="attrib">@see</span> #fetchRawData
   */</span>
  CommPortal.<span class="reserved">prototype</span>.saveData = <span class="reserved">function</span>(dataType,
                                           data,
                                           successCallback,
                                           failureCallback,
                                           objectIdentity,
                                           logText)
  {
    <span class="comment">// Process the parameters</span>
    <span class="reserved">if</span> (typeof objectIdentity == <span class="literal">"string"</span>)
    {
      <span class="comment">// The optional objectIdentity parameter was omitted, so shuffle the</span>
      <span class="comment">// parameters around</span>
      logText = objectIdentity;
      objectIdentity = undefined;
    }
    <span class="comment">// Default the logText if it has not been specified</span>
    <span class="reserved">if</span> (logText === undefined)
    {
      logText = <span class="literal">""</span>;
    }

    <span class="reserved">if</span> (<span class="reserved">this</span>.sessionId)
    {
      <span class="reserved">if</span> (data._cleaned)
      {
        <span class="comment">// We can only save raw data to the server, not cleaned data</span>
        queueError(failureCallback, <span class="reserved">this</span>, CommPortal.ERROR_NOT_RAW_DATA);
      }
      <span class="reserved">else</span>
      {
        var oidString = objectIdentityToString(objectIdentity);
        <span class="reserved">if</span> (oidString)
        {
          <span class="reserved">if</span> (dataType.indexOf(<span class="literal">"?"</span>) &gt; -1)
          {
            <span class="comment">// We already have a query string, so append to it</span>
            dataType += <span class="literal">"&amp;"</span> + oidString;
          }
          <span class="reserved">else</span>
          {
            <span class="comment">// Add this as a query string</span>
            dataType += <span class="literal">"?"</span> + oidString;
          }
        }

        <span class="comment">// Save off our this pointer for use in the callback.</span>
        var connection = <span class="reserved">this</span>;

        <span class="comment">// Create a hidden iFrame to hold the request</span>
        var iFrameId = createUniqueId(<span class="literal">"save"</span>);

        var iFrame = createiFrame(iFrameId);

        <span class="comment">// Compute the basic context info specifying the client version</span>
        var contextInfoVal = getSASContextInfo(connection, false, logText, <span class="literal">""</span>);

        var fields =
        {
          version : <span class="reserved">this</span>.interfaceVersion,
          redirectTo : sRedirectUrl + <span class="literal">"?success=true"</span>,
          errorRedirectTo : sRedirectUrl + <span class="literal">"?error=updateFailed"</span>,
          ContextInfo : contextInfoVal
        };

        <span class="comment">// We need to have the fields defined so far as part of the URL</span>
        var urlFields = encodeFieldsForURL(fields);

        <span class="comment">// We have taken all the existing fields and put them in the URL, so</span>
        <span class="comment">// reset back to no form fields</span>
        fields = {};

        <span class="comment">// Include the data in the form</span>
        fields[dataType] = JSON.stringify(data);

        <span class="comment">// There is part of the url that is common for both post and get</span>
        var baseURL = <span class="reserved">this</span>.server + <span class="literal">"/session"</span> + <span class="reserved">this</span>.sessionId + <span class="literal">"/line/"</span>;

        <span class="reserved">if</span> (<span class="reserved">this</span>.useGet)
        {
          <span class="comment">// Get places ALL the fields in the URL, so add the other ones now</span>
          urlFields += <span class="literal">"&amp;"</span> + encodeFieldsForURL(fields);

          var previousURL = simulateSubmit(iFrame,
                                           baseURL + <span class="literal">"post?"</span> + urlFields);
        }
        <span class="reserved">else</span>
        {
          <span class="comment">// Create a form whose response will be sent to the iframe</span>
          var updateForm = createForm(<span class="literal">"CommPortal_updateSenderForm"</span>,
                                      iFrame,
                                      baseURL + <span class="literal">"data?"</span> + urlFields,
                                      fields);

          <span class="comment">// Set the correct encoding for a data update</span>
          updateForm.encoding = <span class="literal">"multipart/form-data"</span>;

          <span class="comment">// Call the updateRequestCallback function if it is set</span>
          <span class="reserved">if</span> (connection.updateRequestCallback)
          {
            connection.updateRequestCallback(updateForm);
          }

          <span class="comment">// Submit the form we created</span>
          updateForm.submit();
        }

        <span class="comment">// Start polling for the response</span>
        pollForResponse(<span class="reserved">this</span>,
                        iFrame,
                        successCallback,
                        failureCallback,
                        handleDataSavedResponse,
                        previousURL);
      }
    }
    <span class="reserved">else</span>
    {
      queueError(failureCallback, <span class="reserved">this</span>, CommPortal.ERROR_NOT_LOGGED_IN);
    }

    <span class="comment">/**
     * Callback when the save data response is available
     */</span>
    <span class="reserved">function</span> handleDataSavedResponse(url,
                                     connection,
                                     iFrame,
                                     successCallback,
                                     failureCallback)
    {

      <span class="comment">// Call the updateResponseCallback function if it is set</span>
      <span class="reserved">if</span> (connection.updateResponseCallback)
      {
        connection.updateResponseCallback(url);
      }

      <span class="comment">// We have finished with the iFrame and form so can remove them from the DOM</span>
      removeElement(iFrame);
      removeElement(updateForm);

      var queryParams = parseQueryStringParams(url);

      <span class="reserved">if</span> (queryParams.success)
      {
        queueCallback(successCallback,
                      connection);
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// It was some form of error - if one was passed in the url we</span>
        <span class="comment">// use that, else just report unknown.</span>
        var error = queryParams.error;
        var extras = { dataType : dataType };
        <span class="reserved">if</span> (error) {
          extras.error = error;
        }

        queueError(failureCallback,
                   connection,
                   CommPortal.ERROR_DATA_SAVE_ERROR,
                   extras);
      }
    }
  };

  <span class="comment">/**
   * Gets access to the CommPortal contacts, in an easily accessed simple
   * array format.
   * &lt;p&gt;
   * The contacts are passed asynchronously to the provided callback when
   * they are ready.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback that is passed the contacts
   * <span class="attrib">@param</span> {function} successCallback callback that is passed the contacts (See {<span class="attrib">@link</span> callbacks#contactsCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchContacts = <span class="reserved">function</span>(successCallback,
                                                failureCallback)
  {
    var connection = <span class="reserved">this</span>;

    <span class="reserved">if</span> (<span class="reserved">this</span>.cache.contacts)
    {
      returnCachedData();
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// We must query the contacts, our callback handles raw data directly</span>
      <span class="reserved">this</span>.fetchRawData(<span class="literal">"Meta_Subscriber_UC9000_Contacts"</span>,
                        processContacts,
                        failureCallback);
    }

    <span class="comment">/** <span class="attrib">@private</span> */</span>
    <span class="reserved">function</span> processContacts(connection, dataType, getData, objectIdentity)
    {
      <span class="comment">// We return a simple array, of simple objects</span>
      var contacts = [];

      <span class="reserved">for</span> (var i = 0; i &lt; getData.vCard.length; i++)
      {
        var vCard = getData.vCard[i];

        var contact = {};

        <span class="comment">/** <span class="attrib">@private</span> */</span>
        <span class="reserved">function</span> setIfPresent(object, objectField, srcObject, evalText)
        {
          try
          {
            var value = eval(<span class="literal">"srcObject."</span> + evalText + <span class="literal">"._"</span>);

            object[objectField] = value;
          }
          catch (e)
          {
          }
        }

        <span class="comment">/** <span class="attrib">@private</span> */</span>
        <span class="reserved">function</span> setIfArrayPresent(contactField,
                                   vCardArrayField,
                                   vCardObjectField,
                                   omitType)
        {
          <span class="comment">// To make life simpler, we always have an array of these things</span>
          <span class="comment">// present, but it may well be empty.</span>
          contact[contactField] = [];
          <span class="reserved">if</span> (!omitType)
          {
            contact[contactField + <span class="literal">"Type"</span>] = [];
          }

          try
          {
            eval(<span class="literal">"var array = vCard"</span> + <span class="literal">"."</span> + vCardArrayField + <span class="literal">";"</span>);

            <span class="reserved">if</span> (array)
            {
              <span class="reserved">for</span> (var i = 0; i &lt; array.length; i++)
              {
                <span class="reserved">if</span> (typeof vCardObjectField == <span class="literal">"string"</span>)
                {
                  <span class="comment">// We were passed a field name to access the value</span>
                  try
                  {
                    var value = eval(<span class="literal">"array["</span> + i + <span class="literal">"]."</span> + vCardObjectField);

                    contact[contactField][i] = value;
                  }
                  catch (e)
                  {
                  }
                }
                <span class="reserved">else</span>
                {
                  <span class="comment">// We were passed a function that processes a complex object</span>
                  var value = vCardObjectField(array[i]);

                  contact[contactField][i] = value;
                }

                <span class="reserved">if</span> (!omitType)
                {
                  <span class="comment">// See if we have any info to put in the Type field</span>
                  var types = [<span class="literal">"HOME"</span>, <span class="literal">"WORK"</span>, <span class="literal">"CELL"</span>, <span class="literal">"FAX"</span>];
                  var type = <span class="literal">""</span>;
                  <span class="reserved">for</span> (var t = 0; t &lt; types.length; t++)
                  {
                    try
                    {
                      var value = eval(<span class="literal">"array["</span> + i + <span class="literal">"]._"</span> + types[t]);

                      <span class="reserved">if</span> (value)
                      {
                        type = types[t].toLowerCase();
                        break;
                      }
                    }
                    catch (e)
                    {
                    }
                  }
                  contact[contactField + <span class="literal">"Type"</span>][i] = type;
                }
              }
            }
          }
          catch (e)
          {
          }
        }

        var fields =
        [
          <span class="literal">"givenName"</span>,      <span class="literal">"N.GIVEN"</span>,
          <span class="literal">"familyName"</span>,     <span class="literal">"N.FAMILY"</span>,
          <span class="literal">"nickname"</span>,       <span class="literal">"GROUP[0].NICKNAME[0]"</span>,
          <span class="literal">"organization"</span>,   <span class="literal">"GROUP[0].ORG[0].ORGNAME"</span>,
          <span class="literal">"jobTitle"</span>,       <span class="literal">"GROUP[0].TITLE[0]"</span>,
          <span class="literal">"sms"</span>,            <span class="literal">"GROUP[0].SMS[0].ADDRESS"</span>,
          <span class="literal">"uid"</span>,            <span class="literal">"GROUP[0].UID[0]"</span>
        ];

        <span class="reserved">for</span> (var field = 0; field &lt; fields.length; field += 2)
        {
          setIfPresent(contact, fields[field], vCard, fields[field + 1]);
        }

        setIfArrayPresent(<span class="literal">"phone"</span>, <span class="literal">"GROUP[0].TEL"</span>,   <span class="literal">"NUMBER._"</span>);
        setIfArrayPresent(<span class="literal">"email"</span>, <span class="literal">"GROUP[0].EMAIL"</span>, <span class="literal">"USERID._"</span>, true);

        setIfArrayPresent(<span class="literal">"address"</span>, <span class="literal">"GROUP[0].ADR"</span>, <span class="reserved">function</span>(each)
        {
          var parts = [];
          var address = {};

          var fields =
          [
            <span class="literal">"street"</span>,     <span class="literal">"STREET"</span>,
            <span class="literal">"locality"</span>,   <span class="literal">"LOCALITY"</span>,
            <span class="literal">"region"</span>,     <span class="literal">"REGION"</span>,
            <span class="literal">"postalcode"</span>, <span class="literal">"PCODE"</span>,
            <span class="literal">"country"</span>,    <span class="literal">"CTRY"</span>
          ];

          <span class="reserved">for</span> (var field = 0; field &lt; fields.length; field += 2)
          {
            setIfPresent(address, fields[field], each, fields[field + 1]);

            <span class="reserved">if</span> (address[fields[field]])
            {
              parts.push(address[fields[field]]);
            }
          }

          <span class="reserved">if</span> (parts.length)
          {
            address.displayAddress = parts.join(<span class="literal">", "</span>);
          }

          <span class="reserved">return</span> address;
        });

        <span class="comment">// Now we produce some calculated convenience display properties</span>
        var parts = [];
        <span class="reserved">if</span> (contact.givenName)
        {
          parts.push(contact.givenName);
        }
        <span class="reserved">if</span> (contact.familyName)
        {
          parts.push(contact.familyName);
        }
        <span class="reserved">if</span> (parts.length)
        {
          <span class="comment">// This is just a convenience property - it assumes western style</span>
          <span class="comment">// names where a full name is written "firstname lastname"</span>
          contact.displayName = parts.join(<span class="literal">" "</span>);
        }

        <span class="comment">// Add this to the array of contacts</span>
        contacts.push(contact);
      }

      connection.cache.contacts = contacts;

      returnCachedData();
    }

    <span class="comment">/** <span class="attrib">@private</span> */</span>
    <span class="reserved">function</span> returnCachedData()
    {
      queueCallback(successCallback,
                    connection,
                    connection.cache.contacts);
    }
  };

  <span class="comment">/**
   * Adds a contact.
   *
   * <span class="attrib">@param</span> {contact} contact contact object to be added
   * <span class="attrib">@param</span> {function} successCallback callback that is called on success (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #modifyContact
   * <span class="attrib">@see</span> #deleteContacts
   */</span>
  CommPortal.<span class="reserved">prototype</span>.addContact = <span class="reserved">function</span>(contact,
                                             successCallback,
                                             failureCallback)
  {
    <span class="comment">// It's an error when adding to supply the uid,</span>
    <span class="comment">// or processed fields that do not agree with their raw components</span>
    <span class="reserved">if</span> (contact.uid)
    {
      queueError(failureCallback, <span class="reserved">this</span>, CommPortal.ERROR_SUPPLIED_UID);
    }
    <span class="reserved">else</span>
    {
      innerHandleContact(<span class="reserved">this</span>,
                         contact,
                         successCallback,
                         failureCallback);
    }
  };


  <span class="comment">/**
   * Modifies a contact
   *
   * <span class="attrib">@param</span> {contact} contact contact object to be modified
   * <span class="attrib">@param</span> {function} successCallback callback that is called on success (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #addContact
   * <span class="attrib">@see</span> #deleteContacts
   */</span>
  CommPortal.<span class="reserved">prototype</span>.modifyContact = <span class="reserved">function</span>(contact,
                                                successCallback,
                                                failureCallback)
  {
    <span class="comment">// It's an error when modifying not to have a uid.</span>
    <span class="reserved">if</span> (!contact.uid)
    {
      queueError(failureCallback, <span class="reserved">this</span>, CommPortal.ERROR_MISSING_UID);
    }
    <span class="reserved">else</span>
    {
      innerHandleContact(<span class="reserved">this</span>,
                         contact,
                         successCallback,
                         failureCallback);
    }
  };

  <span class="comment">/**
   * Deletes one or a number of contacts.
   *
   * <span class="attrib">@param</span> {String/String[]} uids the id(s) of the contacts to delete
   * <span class="attrib">@param</span> {function} successCallback callback that is called on success (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #addContact
   * <span class="attrib">@see</span> #modifyContact
   */</span>
  CommPortal.<span class="reserved">prototype</span>.deleteContacts = <span class="reserved">function</span>(uids,
                                                 successCallback,
                                                 failureCallback)
  {
    <span class="comment">// We are deleting some contact - so the cache will be invalid</span>
    delete <span class="reserved">this</span>.cache.contacts;

    <span class="reserved">if</span> (typeof uids != <span class="literal">"object"</span>)
    {
      <span class="comment">// We are just deleting a single uid, so turn it in to a single entry array</span>
      uids = [uids];
    }

    var dataType = <span class="literal">"Meta_Subscriber_UC9000_Contacts?vCard.GROUP.UID=*"</span>;

    var data =
    {
      <span class="literal">"_Action"</span>: <span class="literal">"delete"</span>,
      <span class="literal">"vCard"</span> : []
    };

    <span class="reserved">for</span> (var i = 0; i &lt; uids.length; i++)
    {
      data.vCard.push(
        {
          GROUP : [ { UID : [ {<span class="literal">"_"</span> : uids[i] } ] } ]
        });
    }

    <span class="reserved">this</span>.saveData(dataType,
                  data,
                  successCallback,
                  failureCallback);
  };

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> innerHandleContact(connection,
                              contact,
                              successCallback,
                              failureCallback)
  {
    <span class="comment">// Extract and validate the fields in the passed object</span>
    var given = contact.givenName || <span class="literal">""</span>;
    var family = contact.familyName || <span class="literal">""</span>;
    var job = contact.jobTitle || <span class="literal">""</span>;
    var organization = contact.organization || <span class="literal">""</span>;
    var sms = contact.sms || <span class="literal">""</span>;
    var nickname = contact.nickname || <span class="literal">""</span>;
    var uid = contact.uid || <span class="literal">""</span>;

    <span class="comment">// We are changing some contact in some way - so the cache will be invalid</span>
    delete connection.cache.contacts;

    var dataType = <span class="literal">"Meta_Subscriber_UC9000_Contacts?vCard.GROUP.UID="</span> + uid;

    var data =
    {
      <span class="literal">"vCard"</span>:[{<span class="literal">"N"</span>:{<span class="literal">"GIVEN"</span>:{<span class="literal">"_"</span> : given},
                     <span class="literal">"FAMILY"</span>:{<span class="literal">"_"</span> : family}},
                <span class="literal">"GROUP"</span>:[{<span class="literal">"TEL"</span>:[],
                          <span class="literal">"NICKNAME"</span>:[{<span class="literal">"_"</span> : nickname}],
                          <span class="literal">"TITLE"</span>:[{<span class="literal">"_"</span> : job}],
                          <span class="literal">"ORG"</span>:[{<span class="literal">"ORGNAME"</span>:{<span class="literal">"_"</span> : organization}}],
                          <span class="literal">"EMAIL"</span>:[],
                          <span class="literal">"SMS"</span>:[{<span class="literal">"ADDRESS"</span>:{<span class="literal">"_"</span> : sms}}],
                          <span class="literal">"ADR"</span>:[]}]}]
    };

    <span class="reserved">if</span> (uid)
    {
      <span class="comment">// As well as including the UID in the dataType, we need it in the object</span>
      data.vCard[0].GROUP[0].UID = [{<span class="literal">"_"</span> : uid}];
    }

    var email = contact.email || [];
    <span class="reserved">for</span> (var i = 0; i &lt; email.length; i++)
    {
      data.vCard[0].GROUP[0].EMAIL.push({USERID : {<span class="literal">"_"</span> : email[i]}});
    }

    var phone = contact.phone || [];
    <span class="reserved">for</span> (var i = 0; i &lt; phone.length; i++)
    {
      try
      {
        var type = contact.phoneType[i];
      }
      catch (e)
      {
      }

      data.vCard[0].GROUP[0].TEL.push({NUMBER : {<span class="literal">"_"</span> : phone[i]},
                                       _HOME : type == <span class="literal">"home"</span>,
                                       _WORK : type == <span class="literal">"work"</span>,
                                       _CELL : type == <span class="literal">"cell"</span>,
                                       _FAX :  type == <span class="literal">"fax"</span>});
    }

    var address = contact.address || [];
    <span class="reserved">for</span> (var i = 0; i &lt; address.length; i++)
    {
      try
      {
        var type = contact.addressType[i];
      }
      catch (e)
      {
      }

      var adr =
      {
        _HOME : type == <span class="literal">"home"</span>,
        _WORK : type == <span class="literal">"work"</span>
      };

      <span class="reserved">if</span> (address[i].street)
      {
        adr.STREET = {<span class="literal">"_"</span> : address[i].street};
      }
      <span class="reserved">if</span> (address[i].locality)
      {
        adr.LOCALITY = {<span class="literal">"_"</span> : address[i].locality};
      }
      <span class="reserved">if</span> (address[i].region)
      {
        adr.REGION = {<span class="literal">"_"</span> : address[i].region};
      }
      <span class="reserved">if</span> (address[i].pcode)
      {
        adr.PCODE = {<span class="literal">"_"</span> : address[i].pcode};
      }
      <span class="reserved">if</span> (address[i].ctry)
      {
        adr.CTRY = {<span class="literal">"_"</span> : address[i].ctry};
      }

      data.vCard[0].GROUP[0].ADR.push(adr);
    }

    connection.saveData(dataType,
                        data,
                        successCallback,
                        failureCallback);
  }

  <span class="comment">/**
   * Gets access to the list of dialed calls, in an easily accessed simple
   * array format.
   * &lt;p&gt;
   * The array of calls is passed asynchronously to the provided callback when
   * it is ready.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback that is passed the calls (See {<span class="attrib">@link</span> callbacks#callsCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchDialedCalls = <span class="reserved">function</span>(successCallback,
                                                   failureCallback)
  {
    commonFetchCallList(<span class="reserved">this</span>,
                        successCallback,
                        failureCallback,
                        <span class="literal">"DialedCalls"</span>);
  };

  <span class="comment">/**
   * Gets access to the list of answered calls, in an easily accessed simple
   * array format.
   * &lt;p&gt;
   * The array of calls is passed asynchronously to the provided callback when
   * it is ready.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback that is passed the calls (See {<span class="attrib">@link</span> callbacks#callsCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchAnsweredCalls = <span class="reserved">function</span>(successCallback,
                                                     failureCallback)
  {
    commonFetchCallList(<span class="reserved">this</span>,
                        successCallback,
                        failureCallback,
                        <span class="literal">"AnsweredCalls"</span>);
  };

  <span class="comment">/**
   * Gets access to the list of missed calls, in an easily accessed simple
   * array format.
   * &lt;p&gt;
   * The array of calls is passed asynchronously to the provided callback when
   * it is ready.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback that is passed the calls (See {<span class="attrib">@link</span> callbacks#callsCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.fetchMissedCalls = <span class="reserved">function</span>(successCallback,
                                                   failureCallback)
  {
    commonFetchCallList(<span class="reserved">this</span>,
                        successCallback,
                        failureCallback,
                        <span class="literal">"MissedCalls"</span>);
  };

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> commonFetchCallList(connection,
                               successCallback,
                               failureCallback,
                               type)
  {
    var requiredData =
    {
      mswCallLists  : <span class="literal">"Meta_Subscriber_CallLists"</span>,
      sdpCallLists  : <span class="literal">"Meta_Subscriber_MetaSphere_CallList"</span>,
      cos           : <span class="literal">"Meta_Subscriber_MetaSphere_ClassOfService"</span>,
      caps          : <span class="literal">"Meta_Subscriber_MetaSphere_SubscriberCapabilities"</span>,
      session       : <span class="literal">"Session"</span>
    };

    commonFetchRequiredData(requiredData, connection, returnCachedData);

    <span class="reserved">function</span> returnCachedData()
    {
      var isMetaSwitchSubscriber =
        connection.cache.session.ManagedSubscribers[0].Devices[0].IsMetaSwitchSubscriber;

      <span class="comment">// Determine which of the call lists should apply</span>
      <span class="reserved">if</span> (type == <span class="literal">"DialedCalls"</span>)
      {
        var callList = isMetaSwitchSubscriber ? connection.cache.mswCallLists :
                                                null;
      }
      <span class="reserved">else</span>
      {
        var icmEnabled = connection.cache.caps.LogicBasedRedirect &amp;&amp;
                         connection.cache.cos.IcmAllowed;

        <span class="reserved">if</span> (isMetaSwitchSubscriber)
        {
          var callList = icmEnabled ? connection.cache.sdpCallLists :
                                      connection.cache.mswCallLists;
        }
        <span class="reserved">else</span>
        {
          var callList = icmEnabled ? connection.cache.sdpCallLists :
                                      null;
        }
      }

      <span class="reserved">if</span> (callList)
      {
        queueCallback(successCallback,
                      connection,
                      callList[type].Call);
      }
      <span class="reserved">else</span>
      {
        queueError(failureCallback,
                   connection,
                   CommPortal.ERROR_NO_CALLLISTS);
      }
    }
  };

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> commonFetchRequiredData(requiredData,
                                   connection,
                                   returnCachedData)
  {
    <span class="reserved">function</span> gotRequiredData()
    {
      var gotAll = true;
      <span class="reserved">for</span> (var i in requiredData)
      {
        <span class="reserved">if</span> (requiredData.hasOwnProperty(i))
        {
          gotAll = gotAll &amp;&amp; !!connection.cache[i];
        }
      }
      <span class="reserved">return</span> gotAll;
    }

    <span class="reserved">if</span> (gotRequiredData())
    {
      returnCachedData();
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// Query all the data</span>
      var dataTypes = [];

      <span class="reserved">for</span> (var i in requiredData)
      {
        <span class="reserved">if</span> (requiredData.hasOwnProperty(i) &amp;&amp; !connection.cache[i])
        {
          dataTypes.push(requiredData[i]);
        }
      }

      connection.fetchData(dataTypes,
                           processData,
                           errorOnData);
    }

    <span class="reserved">function</span> processData(connection, dataType, getData, objectIdentity)
    {
      <span class="reserved">for</span> (var i in requiredData)
      {
        <span class="reserved">if</span> (requiredData.hasOwnProperty(i) &amp;&amp; requiredData[i] == dataType)
        {
          connection.cache[i] = getData;
          break;
        }
      }

      <span class="reserved">if</span> (gotRequiredData())
      {
        returnCachedData();
      }
    }

    <span class="reserved">function</span> errorOnData(connection, error)
    {
      <span class="comment">// We simply cache any error we got</span>
      <span class="reserved">for</span> (var i in requiredData)
      {
        <span class="reserved">if</span> (requiredData.hasOwnProperty(i) &amp;&amp; requiredData[i] == error.dataType)
        {
          connection.cache[i] = error.getErrors;
          break;
        }
      }
    }
  }

  <span class="comment">/**
   * Invalidates the cache so that subsequent data fetches get the latest data
   * direct from the server.
   */</span>
  CommPortal.<span class="reserved">prototype</span>.invalidateCache = <span class="reserved">function</span>()
  {
    <span class="reserved">this</span>.cache = {};
  };

  <span class="comment">/**
   * Indicates state: Command to start call has yet to be issued
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.CALLSTATE_INITIAL         = 0;
  <span class="comment">/**
   * Indicates state: Command to start call has been issued
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.CALLSTATE_CALLING         = 1;
  <span class="comment">/**
   * Indicates state: The phone that forms the first leg of the call is ringing
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.CALLSTATE_FIRST_RINGING   = 2;
  <span class="comment">/**
   * Indicates state: The first phone has been answered
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.CALLSTATE_FIRST_ANSWERED  = 3;
  <span class="comment">/**
   * Indicates state: The phone that forms the second leg of the call is
   * ringing
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.CALLSTATE_SECOND_RINGING  = 4;
  <span class="comment">/**
   * Indicates state: The second phone has been answered
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.CALLSTATE_SECOND_ANSWERED = 5;
  <span class="comment">/**
   * Indicates state: The command to cancel the call has been issued.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.CALLSTATE_CLEARING        = 6;
  <span class="comment">/**
   * Indicates state: The call has ended.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.CALLSTATE_CLEARED         = 7;
  <span class="comment">/**
   * Indicates state: The call has failed.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.CALLSTATE_FAILED          = 8;
  <span class="comment">/**
   * Indicates state: The call still exists, but CommPortal has stepped out of
   * the call control path and so no further interaction with the call is
   * possible via this SDK.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.CALLSTATE_FINAL           = 9;

  var callingStates = [];
  callingStates[CommPortal.CALLSTATE_INITIAL        ] = <span class="literal">"Initial state"</span>;
  callingStates[CommPortal.CALLSTATE_CALLING        ] = <span class="literal">"Calling"</span>;
  callingStates[CommPortal.CALLSTATE_FIRST_RINGING  ] = <span class="literal">"First phone ringing"</span>;
  callingStates[CommPortal.CALLSTATE_FIRST_ANSWERED ] = <span class="literal">"First phone answered"</span>;
  callingStates[CommPortal.CALLSTATE_SECOND_RINGING ] = <span class="literal">"Second phone ringing"</span>;
  callingStates[CommPortal.CALLSTATE_SECOND_ANSWERED] = <span class="literal">"Second phone answered"</span>;
  callingStates[CommPortal.CALLSTATE_CLEARING       ] = <span class="literal">"Canceling call"</span>;
  callingStates[CommPortal.CALLSTATE_CLEARED        ] = <span class="literal">"Call ended"</span>;
  callingStates[CommPortal.CALLSTATE_FAILED         ] = <span class="literal">"Call failed"</span>;
  callingStates[CommPortal.CALLSTATE_FINAL          ] = <span class="literal">"Final state"</span>;

  <span class="comment">/**
   * Indicates state: The subscriber's phone is ringing
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   * <span class="attrib">@type</span> string
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.INCOMINGCALLSTATE_RINGING               = <span class="literal">"ringing"</span>;
  <span class="comment">/**
   * Indicates state: The subscriber's phone is not ringing
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   * <span class="attrib">@type</span> string
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.INCOMINGCALLSTATE_NOT_RINGING           = <span class="literal">"not-ringing"</span>;
  <span class="comment">/**
   * Indicates type: The incoming call type normal
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   * <span class="attrib">@type</span> string
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.INCOMINGCALLTYPE_NORMAL                 = <span class="literal">"normal"</span>;
  <span class="comment">/**
   * Indicates type: The incoming call type live message screening
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   * <span class="attrib">@type</span> string
   * <span class="attrib">@final</span>
   */</span>
  CommPortal.INCOMINGCALLTYPE_LIVE_MESSAGE_SCREENING = <span class="literal">"live-message-screening"</span>;

  <span class="comment">/**
   * Makes a phone call.
   *
   * <span class="attrib">@param</span> {String} numberTo phone number to call
   * <span class="attrib">@param</span> {String} numberFrom [optional] phone number to call from
   * <span class="attrib">@param</span> {function} progressCallback called multiple times with progress state (See {<span class="attrib">@link</span> callbacks#progressCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #cancelCall
   */</span>
  CommPortal.<span class="reserved">prototype</span>.makeCall = <span class="reserved">function</span>(numberTo, numberFrom, progressCallback, failureCallback)
  {
    var connection = <span class="reserved">this</span>;

    <span class="comment">// Process the parameters</span>
    <span class="reserved">if</span> (typeof numberFrom == <span class="literal">"function"</span>)
    {
      <span class="comment">// The optional numberFrom parameter was omitted, so shuffle the other</span>
      <span class="comment">// parameters around</span>
      failureCallback = progressCallback;
      progressCallback = numberFrom;
      numberFrom = undefined;
    }

    <span class="reserved">if</span> (!numberFrom)
    {
      <span class="comment">// No from number was provided, so use the subscriber's own number</span>
      connection.fetchSubscriberNumber(<span class="reserved">function</span>(connection, number)
      {
        numberFrom = number;
        innerMakeCall(connection, numberTo, numberFrom, progressCallback, failureCallback);
      },
      failureCallback);
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// We already have all the numbers we need, so make the call now</span>
      innerMakeCall(connection, numberTo, numberFrom, progressCallback, failureCallback);
    }

    <span class="comment">// Define a function to actually make the call.  The strategy here is to</span>
    <span class="comment">//</span>
    <span class="comment">// -  fire off an action to CommPortal Server to make the call.</span>
    <span class="comment">// -  assuming the action was accepted successfully, use a dedicated</span>
    <span class="comment">//    instance of the CommPortalEvent class to listen for events occurring</span>
    <span class="comment">//    on that call.</span>
    <span class="reserved">function</span> innerMakeCall(connection, numberTo, numberFrom, progressCallback, failureCallback)
    {
      <span class="reserved">if</span> (connection.getCallId() != null)
      {
        <span class="comment">// We can't have more than one call in progress at a time</span>
        queueError(failureCallback,
                   connection,
                   CommPortal.ERROR_CALL_IN_PROGRESS,
                   { callId : connection.getCallId() });
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// Reset the call state and store the callbacks.</span>
        connection.setCallState(CommPortal.CALLSTATE_INITIAL);
        connection.callProgressCallback = progressCallback;
        connection.callFailureCallback = failureCallback;

        <span class="comment">// Define a function for dealing with events that happen to the call</span>
        <span class="comment">// being made.  This is essentially a mapping from CommPortal Server</span>
        <span class="comment">// events to CommPortal.CALLSTATE_*.</span>
        <span class="reserved">function</span> eventCallback(connection, number, eventType, eventData, eventSubType)
        {
          <span class="reserved">if</span> (eventSubType == <span class="literal">"ServiceInitiatedEvent"</span>)
          {
            connection.setCallState(CommPortal.CALLSTATE_FIRST_RINGING);
          }
          <span class="reserved">else</span> <span class="reserved">if</span> (eventSubType == <span class="literal">"OriginatedEvent"</span>)
          {
            connection.setCallState(CommPortal.CALLSTATE_FIRST_ANSWERED);
          }
          <span class="reserved">else</span> <span class="reserved">if</span> (eventSubType == <span class="literal">"DeliveredEvent"</span>)
          {
            connection.setCallState(CommPortal.CALLSTATE_SECOND_RINGING);
          }
          <span class="reserved">else</span> <span class="reserved">if</span> (eventSubType == <span class="literal">"EstablishedEvent"</span>)
          {
            <span class="comment">// The called party has answered, so the call is now connected.</span>
            connection.setCallState(CommPortal.CALLSTATE_SECOND_ANSWERED);
          }
          <span class="reserved">else</span> <span class="reserved">if</span> (eventSubType == <span class="literal">"ConnectionClearedEvent"</span>)
          {
            <span class="reserved">if</span> (eventData.cause._ == <span class="literal">"pathReplacement"</span>)
            {
              <span class="comment">// EAS has stepped out of the call path but the call still</span>
              <span class="comment">// exists.</span>
              connection.setCallState(CommPortal.CALLSTATE_FINAL);
            }
            <span class="reserved">else</span>
            {
              connection.setCallState(CommPortal.CALLSTATE_CLEARED);
            }
          }
          <span class="reserved">else</span> <span class="reserved">if</span> (eventSubType == <span class="literal">"FailedEvent"</span>)
          {
            <span class="reserved">if</span> (connection.callState &gt;= CommPortal.CALLSTATE_FIRST_ANSWERED)
            {
              <span class="comment">// An error after the first leg is answered will be communicated</span>
              <span class="comment">// via audio to the first phone, so just treat the call as ended.</span>
              connection.setCallState(CommPortal.CALLSTATE_CLEARED);
            }
            <span class="reserved">else</span>
            {
              var error = CommPortal.ERROR_UNKNOWN;

              <span class="comment">// Try to work out why the call failed.</span>
              <span class="reserved">if</span> (eventData.cause._ == <span class="literal">"busy"</span>)
              {
                error = CommPortal.ERROR_LINE_BUSY;
              }
              <span class="reserved">else</span> <span class="reserved">if</span> (eventData.cause._ == <span class="literal">"callNotAnswered"</span>)
              {
                error = CommPortal.ERROR_CALL_NOT_ANSWERED;
              }

              connection.setCallState(CommPortal.CALLSTATE_FAILED, error);
            }
          }
        }

        <span class="comment">// Define a function to be called when the action has been successfully</span>
        <span class="comment">// accepted by CommPortal Server.</span>
        <span class="reserved">function</span> actionCallback(connection, actionData)
        {
          <span class="comment">// First check to see if this is a response to a MakeCall action</span>
          <span class="comment">// request.</span>
          <span class="reserved">if</span> (actionData.objectType)
          {
            <span class="reserved">if</span> (actionData.objectType == <span class="literal">"MakeCallResponse"</span>)
            {
              <span class="comment">// The response is for the expected action.  Store the callID and</span>
              <span class="comment">// deviceID from the response so that the call can be canceled</span>
              <span class="comment">// later.</span>
              <span class="reserved">if</span> (actionData.callingDevice != null)
              {
                connection.callId   = actionData.callingDevice.callID;
                connection.deviceId = actionData.callingDevice.deviceID;
              }

              <span class="comment">// Now use the dedicated instance of CommPortalEvent to listen</span>
              <span class="comment">// for events on this call.</span>
              connection.setCallState(CommPortal.CALLSTATE_CALLING);
              connection.callEvent.subscribeToEvents([<span class="literal">"Connection"</span>],
                                                     eventCallback);
            }
            <span class="reserved">else</span>
            {
              connection.setCallState(CommPortal.CALLSTATE_FAILED,
                                      CommPortal.ERROR_UNKNOWN);
            }
          }
        }

        <span class="comment">// Define a function to be called when the action has failed - this</span>
        <span class="comment">// means we can send a better error than "action failed" back to the</span>
        <span class="comment">// caller.</span>
        <span class="reserved">function</span> actionFailedCallback(connection, error)
        {
          var actionData = error.actionData;
          error = CommPortal.ERROR_UNKNOWN;

          <span class="reserved">if</span> ((actionData != null) &amp;&amp;
              (actionData.objectType == <span class="literal">"ErrorValue"</span>) &amp;&amp;
              (actionData.operation == <span class="literal">"invalidCalledNumber"</span>))
          {
            error = CommPortal.ERROR_INVALID_NUMBER;
          }

          connection.setCallState(CommPortal.CALLSTATE_FAILED, error);
        }

        <span class="comment">// Pause polling for events.  This is because some browsers only</span>
        <span class="comment">// support a maximum of 2 simultaneous connections to a single server,</span>
        <span class="comment">// and we don't want this to interfere with making this telephone call.</span>
        connection.commPortalEvent.pausePolling();

        <span class="comment">// Fire off the action to make the call.</span>
        connection.performAction({
                                   objectType : <span class="literal">"MakeCall"</span>,
                                   callingDevice : numberFrom,
                                   calledDirectoryNumber : numberTo,
                                   autoOriginate : <span class="literal">"prompt"</span>,
                                   callCharacteristics : { assistCall : false }
                                 },
                                 actionCallback,
                                 actionFailedCallback);
      }
    }
  };

  <span class="comment">/**
   * Cancels making a phone call.
   *
   * &lt;p&gt;
   * Can be used to cancel the last call started via {<span class="attrib">@link</span> makeCall()}
   * provided that the call has not already ended nor reached the
   * CommPortal.CALLSTATE_FINAL call state.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * Note that the progressCallback of
   * the corresponding {<span class="attrib">@link</span> #makeCall} will be called to tell it that the
   * call has been canceled.
   * &lt;/p&gt;
   *
   * <span class="attrib">@param</span> {function} successCallback callback that is called on success (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   *
   * <span class="attrib">@see</span> #makeCall
   */</span>
  CommPortal.<span class="reserved">prototype</span>.cancelCall = <span class="reserved">function</span>(successCallback,
                                             failureCallback)
  {
    var callId = <span class="reserved">this</span>.getCallId();

    <span class="reserved">if</span> ((callId != null) &amp;&amp;
        (<span class="reserved">this</span>.callState &lt; CommPortal.CALLSTATE_CLEARED))
    {
      <span class="comment">// Record the fact that we are canceling the call.</span>
      <span class="reserved">this</span>.setCallState(CommPortal.CALLSTATE_CLEARING);

      <span class="comment">// Define a function to be called when the action has been successfully</span>
      <span class="comment">// accepted by CommPortal Server.  The event-listening interface should</span>
      <span class="comment">// report a final state anyway, but do it here as well to be defensive.</span>
      <span class="reserved">function</span> actionCallback(connection, actionData)
      {
        <span class="comment">// First check to see if the response is for an EndCall action request.</span>
        <span class="reserved">if</span> (actionData.objectType == <span class="literal">"EndCallResponse"</span>)
        {
          connection.setCallState(CommPortal.CALLSTATE_CLEARED);
        }
        <span class="reserved">else</span>
        {
          connection.setCallState(CommPortal.CALLSTATE_FAILED,
                                  CommPortal.ERROR_UNKNOWN);
        }
      }

      <span class="comment">// Fire off the action to cancel the call.</span>
      <span class="reserved">this</span>.performAction({
                           objectType : <span class="literal">"EndCall"</span>,
                           connectionToBeCleared : { callID : callId,
                                                     deviceID : <span class="reserved">this</span>.deviceId }
                         },
                         actionCallback,
                         failureCallback);

      <span class="comment">// Signal that the cancel request was accepted.</span>
      queueCallback(successCallback, connection);
    }
    <span class="reserved">else</span>
    {
      queueError(failureCallback,
                 <span class="reserved">this</span>,
                 CommPortal.ERROR_NO_CURRENT_CALL);
    }
  };

  <span class="comment">/**
   * Sets the new state and does associated housekeeping, including calling the
   * appropriate callback.
   *
   * <span class="attrib">@param</span> {CommPortal.CALLSTATE_*} newState the new call state.
   * <span class="attrib">@param</span> {CommPortalCall.Error} error (optional) error that occurred.
   * <span class="attrib">@private</span>
   */</span>
  CommPortal.<span class="reserved">prototype</span>.setCallState = <span class="reserved">function</span>(newState, error)
  {
    var oldState = <span class="reserved">this</span>.callState;
    <span class="reserved">this</span>.callState = newState;
    var callId = <span class="reserved">this</span>.getCallId();

    <span class="comment">// Ignore this request unless it denotes a change in state.</span>
    <span class="reserved">if</span> (oldState != newState)
    {
      <span class="comment">// If this is an error state, call the failure callback.</span>
      <span class="reserved">if</span> ((error != null) &amp;&amp; (<span class="reserved">this</span>.callFailureCallback != null))
      {
        queueError(<span class="reserved">this</span>.callFailureCallback, <span class="reserved">this</span>, error);
      }
      <span class="reserved">else</span> <span class="reserved">if</span> ((<span class="reserved">this</span>.callProgressCallback != null) &amp;&amp;
               (newState &gt; CommPortal.CALLSTATE_INITIAL))
      {
        <span class="comment">// Report the current state to the progress callback.  Don't bother</span>
        <span class="comment">// reporting the initial call state event as this is of no interest to</span>
        <span class="comment">// the caller.</span>
        var stateObject =
        {
          state : newState,
          message : callingStates[newState],
          toString : <span class="reserved">function</span>() {<span class="reserved">return</span> <span class="reserved">this</span>.message;}
        };
        queueCallback(<span class="reserved">this</span>.callProgressCallback, <span class="reserved">this</span>, callId, stateObject);
      }

      <span class="comment">// A state higher than CLEARING indicates that there is no further</span>
      <span class="comment">// processing for this call, so tidy up.</span>
      <span class="reserved">if</span> (newState &gt; CommPortal.CALLSTATE_CLEARING)
      {
        <span class="reserved">this</span>.callEvent.unsubscribeFromEvents([<span class="literal">"Connection"</span>]);
        <span class="reserved">this</span>.commPortalEvent.restartPolling();
        delete <span class="reserved">this</span>.callId;
        delete <span class="reserved">this</span>.deviceId;
        delete <span class="reserved">this</span>.callFailureCallback;
        delete <span class="reserved">this</span>.callProgressCallback;
      }
    }
  };

  <span class="comment">/**
   * CORE API: Subscribe to events
   *
   * &lt;p&gt;
   * Sets up a subscription for events that will be passed to the given
   * callback.
   *
   * &lt;p&gt;
   * Can be called multiple times with different events specified, to
   * allow different events to be routed to different callbacks, or with
   * multiple events at once to pass them all to the same callback.
   * A subsequent call with a different callback will replace any existing
   * callback for that event.
   *
   * &lt;p&gt;
   * Possible event strings are
   * &lt;ul&gt;
   *   &lt;li&gt;IncomingCallManager - changes to ICM configuration&lt;/li&gt;
   *   &lt;li&gt;DoNotDisturb - changes to DND configuration&lt;/li&gt;
   *   &lt;li&gt;FindMeFollowMe - changes to MetaSwitch FMFM configuration&lt;/li&gt;
   *   &lt;li&gt;UnconditionalCallForwarding - changes to UCF configuration&lt;/li&gt;
   *   &lt;li&gt;VoicemailCount - changes to the numbers of read and unread voicemails&lt;/li&gt;
   *   &lt;li&gt;Contacts - changes to the contact list&lt;/li&gt;
   *   &lt;li&gt;ClickToDialConfig - changes to the click-to-dial configuration&lt;/li&gt;
   *   &lt;li&gt;IncomingCall - provides details of incoming calls&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * &lt;p&gt;
   * The optional target line number may be specified when requesting events on
   * other than the logged in subscriber's line.  (Only certain types of
   * subscriber are able to access other lines in this way).
   *
   * &lt;p&gt;
   * The optional timeout parameter specifies a timeout which may be used to
   * tweak the number of requests that go out over the wire.  If multiple
   * calls use different timeout settings then the last value passed to any of
   * the calls is the one used.
   *
   * &lt;p&gt;
   * You should be aware that some events can't be listened for simultaneously,
   * for instance, you can't do both of listen for incoming call events AND
   * listen on multiple lines at once.  In the case when incompatible events
   * are requested, an error will be returned.
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@see</span> #unsubscribeFromEvents
   *
   * <span class="attrib">@param</span> {String/String[]} events which events should be subscribed to
   * <span class="attrib">@param</span> {function} eventCallback callback called for each event (See {<span class="attrib">@link</span> callbacks#eventCallback})
   * <span class="attrib">@param</span> {String} target [optional] line number to request events on
   * <span class="attrib">@param</span> {Integer} timeout [optional] maximum timeout to use in milliseconds
   *
   * <span class="attrib">@return</span> undefined on success, or an error value such as if asked to start
   *   listening for events that are incompatible or if asked to listen to
   *   an event that the subscriber is not allowed to listen for
   * <span class="attrib">@type</span> error
   */</span>
  CommPortal.<span class="reserved">prototype</span>.subscribeToEvents = <span class="reserved">function</span>(events,
                                                    eventCallback,
                                                    target,
                                                    timeout)
  {
    <span class="reserved">return</span> <span class="reserved">this</span>.commPortalEvent.subscribeToEvents(events,
                                                  eventCallback,
                                                  target,
                                                  timeout);
  };

  <span class="comment">/**
   * CORE API: Unsubscribe from events
   *
   * &lt;p&gt;
   * Clears a subscription for specified events.
   *
   * &lt;p&gt;
   * Can be called multiple times with different events specified, or
   * with multiple events at once.  Only the events given are unsubscribed
   * from, and the groupings used when unsubscribing do not need to match those
   * used when subscribing.
   *
   * &lt;p&gt;
   * The optional line number may be specified when unsubscribing from events
   * on other than the logged in subscriber's line.  (Only certain types of
   * subscriber are able to access other lines in this way).
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@see</span> #subscribeToEvents
   *
   * <span class="attrib">@param</span> {String/String[]} events which events should be unsubscribed from
   * <span class="attrib">@param</span> {String} target [optional] phone number of line that event subscription relates to
   *
   * <span class="attrib">@return</span> undefined on success, or an error value if there was no
   *   corresponding subscription request found
   * <span class="attrib">@type</span> error
   */</span>
  CommPortal.<span class="reserved">prototype</span>.unsubscribeFromEvents = <span class="reserved">function</span>(events,
                                                        target)
  {
    <span class="reserved">return</span> <span class="reserved">this</span>.commPortalEvent.unsubscribeFromEvents(events, target);
  };

  <span class="comment">/**
   * Set the incoming call handler, so that it is notified when an incoming
   * call occurs.
   *
   * &lt;p&gt;
   * The optional target phone number may be specified when needing to handle
   * incoming calls on other than the logged in subscriber's phone line.
   * (Only certain types of subscriber are able to access other phone lines in
   * this way).
   *
   * &lt;p&gt;
   * You cannot set call handlers for multiple phone lines at once, nor mix
   * this method with the core API method {<span class="attrib">@link</span> #subscribeToEvents}
   * when that would also involve multiple target phone lines.  In such cases
   * a synchronous error is returned.
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@see</span> #clearIncomingCallHandler
   * <span class="attrib">@see</span> #subscribeToEvents
   *
   * <span class="attrib">@param</span> {function} incomingCallback callback called for each incoming call (See {<span class="attrib">@link</span> callbacks#incomingCallback})
   * <span class="attrib">@param</span> {String} target [optional] phone number to monitor for incoming calls
   *
   * <span class="attrib">@return</span> undefined on success, or an error value if adding this call
   *   handler is incompatible with other event monitoring already in place, or
   *   if the subsriber account is not configured to allow incoming call
   *   notifications
   * <span class="attrib">@type</span> error
   */</span>
  CommPortal.<span class="reserved">prototype</span>.setIncomingCallHandler = <span class="reserved">function</span>(incomingCallback,
                                                         target)
  {
    <span class="reserved">function</span> eventCallback(connection, number, eventType, eventData)
    {
      incomingCallback(connection, number, eventData);
    }

    <span class="reserved">return</span> <span class="reserved">this</span>.subscribeToEvents([<span class="literal">"IncomingCall"</span>],
                                  eventCallback,
                                  target);
  };

  <span class="comment">/**
   * Clear the incoming call handler
   *
   * &lt;p&gt;
   * The optional target line number may be specified to match that provided
   * to setIncomingCallHandler.
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@see</span> #setIncomingCallHandler
   *
   * <span class="attrib">@param</span> {String} target [optional] line number
   *
   * <span class="attrib">@return</span> undefined on success, or an error value such as if there is no
   *   corresponding call handler currently set
   * <span class="attrib">@type</span> error
   */</span>
  CommPortal.<span class="reserved">prototype</span>.clearIncomingCallHandler = <span class="reserved">function</span>(target)
  {
    <span class="reserved">return</span> <span class="reserved">this</span>.unsubscribeFromEvents([<span class="literal">"IncomingCall"</span>], target);
  };

  <span class="comment">/**
   * CORE API: Perform the server action as described by the data parameter.
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {Object} data contents of service indication describing the action
   * <span class="attrib">@param</span> {function} actionCallback callback called when successfully
   *        performed the action (See {<span class="attrib">@link</span> callbacks#actionCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs  (See
   *        {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.performAction = <span class="reserved">function</span>(data,
                                                actionCallback,
                                                failureCallback)
  {
    <span class="reserved">if</span> (<span class="reserved">this</span>.sessionId)
    {
      <span class="comment">// Save off our this pointer for use in the callback</span>
      var connection = <span class="reserved">this</span>;

      <span class="comment">// Set the version and the data</span>
      var fields =
      {
        version : <span class="reserved">this</span>.interfaceVersion,
        request : JSON.stringify(data)
      };

      <span class="comment">// Encode the fields to add to the url</span>
      var urlFields = encodeFieldsForURL(fields);

      <span class="comment">// Create the base URL</span>
      var baseURL = <span class="reserved">this</span>.server + <span class="literal">"/session"</span> + <span class="reserved">this</span>.sessionId + <span class="literal">"/line/"</span>;

      <span class="comment">// Create a uniquely named callback function for this request</span>
      var callbackName = createUniqueId(<span class="literal">"callback"</span>);
      var callback = <span class="literal">"callback=CommPortal."</span> + callbackName;

      var url = baseURL + <span class="literal">"action.js?"</span> + callback + <span class="literal">"&amp;"</span> + urlFields;

      <span class="comment">// Register the uniquely-named callback</span>
      CommPortal[callbackName] = <span class="reserved">function</span>(data)
      {
        <span class="comment">// Call the getReponseCallback function if it is set</span>
        <span class="reserved">if</span> (connection.getResponseCallback)
        {
          connection.getResponseCallback(callbackName,
                                         null,
                                         <span class="literal">"action.js"</span>,
                                         data,
                                         null,
                                         null,
                                         null);
        }

        try
        {
          handleActionResponse(data, actionCallback, failureCallback);
        }
        finally
        {
          <span class="comment">// Remove the now unneeded script tag.</span>
          removeElement(scriptTag);

          <span class="comment">// This callback is now finished with, get rid of it</span>
          delete CommPortal[callbackName];
        }
      };
      <span class="comment">// Add a new script tag with that URL.  Once loaded, it will kick</span>
      <span class="comment">// off our callback.</span>
      var scriptTag = appendScriptTag(url);

      <span class="comment">// Call the getRequestCallback function if it is set</span>
      <span class="reserved">if</span> (connection.getRequestCallback)
      {
        connection.getRequestCallback(url);
      }
    }
    <span class="reserved">else</span>
    {
      queueError(failureCallback, <span class="reserved">this</span>, CommPortal.ERROR_NOT_LOGGED_IN);
    }

    <span class="comment">// Callback to handle the action response</span>
    <span class="reserved">function</span> handleActionResponse(data,
                                  actionCallback,
                                  failureCallback)
    {
      <span class="reserved">if</span> (data.objectType != <span class="literal">"ErrorValue"</span>)
      {
        <span class="comment">// We successfully performed the action</span>
        queueCallback(actionCallback,
                      connection,
                      data);
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// We failed to perform the action</span>
        queueError(failureCallback,
                   connection,
                   CommPortal.ERROR_ACTION_INVALID_DATA,
                   { actionData : data });
      }
    }
  };

  <span class="comment">/**
   * Redirect an incoming call to another phone number
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {String} callId the id of the call to be redirected
   * <span class="attrib">@param</span> {String} device the device number that is receiving the call
   * <span class="attrib">@param</span> {String} newNumber the new phone number to redirect the call to
   * <span class="attrib">@param</span> {function} successCallback callback called when the call is successfully redirected (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.redirectCall = <span class="reserved">function</span>(callId,
                                               device,
                                               newNumber,
                                               successCallback,
                                               failureCallback)
  {
    <span class="comment">// Create the data to submit to the server</span>
    var data =
    {
      objectType : <span class="literal">"DeflectCall"</span>,
      callToBeDiverted : {
        deviceID : device,
        callID : callId
      },
      newDestination : newNumber,
      reason : <span class="literal">"callForward"</span>
    };

    <span class="reserved">this</span>.performAction(data,
                       successCallback,
                       failureCallback);
  };

  <span class="comment">/**
   * Reject an incoming call.
   *
   * &lt;p/&gt;
   * The rejected call may be ended, or sent to email instead dependent on the
   * line's settings.
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   *
   * <span class="attrib">@param</span> {String} callId the id of the call to be rejected
   * <span class="attrib">@param</span> {String} device the device number that is receiving the call
   * <span class="attrib">@param</span> {function} successCallback callback called when the call is successfully terminated (See {<span class="attrib">@link</span> callbacks#successCallback})
   * <span class="attrib">@param</span> {function} failureCallback callback called if an error occurs (See {<span class="attrib">@link</span> callbacks#failureCallback})
   */</span>
  CommPortal.<span class="reserved">prototype</span>.rejectCall = <span class="reserved">function</span>(callId,
                                             device,
                                             successCallback,
                                             failureCallback)
  {
    <span class="comment">// Create the data to submit to the server</span>
    var data =
    {
      objectType : <span class="literal">"EndCall"</span>,
      connectionToBeCleared : {
        callID : callId,
        deviceID : device
      }
    };

    <span class="reserved">this</span>.performAction(data,
                       successCallback,
                       failureCallback);
  };

  <span class="comment">/**
   * Make a Service Assurance Server (SAS) log.
   *
   * &lt;p&gt;WARNING.  Calling this function places additional load on the Service
   * Assurance Server and should only be called if you are sure that your
   * Service Assurance Server has sufficient capacity.&lt;/p&gt;
   *
   * &lt;p&gt;
   * The Service Assurance Server supports the ISO-8859-1 character set so
   * the summary and details text must only use these characters.
   *&lt;/p&gt;
   * <span class="attrib">@param</span> {String} summary the summary information. This can be up to 128
   *                 characters long. Any additional characters will be
   *                 discarded and replaced with "..."
   *                 It must not be blank or the log will be ignored.
   * <span class="attrib">@param</span> {String} details the detailed description. This can be up to 512
   *                 characters long. Any additional characters will be
   *                 discarded and replaced with "...".
   * <span class="attrib">@see</span> #makeSASErrorLog
   */</span>
  CommPortal.<span class="reserved">prototype</span>.makeSASLog = <span class="reserved">function</span>(summary, details)
  {
    makeSASLogInternal(<span class="reserved">this</span>, false, summary, details);
  };

  <span class="comment">/**
   * Make a Service Assurance Server (SAS) error log.
   *
   * &lt;p&gt;WARNING.  Calling this function places additional load on the Service
   * Assurance Server and should only be called if you are sure that your
   * Service Assurance Server has sufficient capacity.&lt;/p&gt;
   *
   *&lt;p&gt;
   * The Service Assurance Server supports the ISO-8859-1 character set so
   * the summary and details text must only use these characters.
   *&lt;/p&gt;
   * <span class="attrib">@param</span> {String} summary the summary information. This can be up to 128
   *                 characters long. Any additional characters will be
   *                 discarded and replaced with "..."
   *                 It must not be blank or the log will be ignored.
   * <span class="attrib">@param</span> {String} details the detailed description. This can be up to 512
   *                 characters long. Any additional characters will be
   *                 discarded and replaced with "...". A stack trace is
   *                 automatically appended to the details.
   * <span class="attrib">@see</span> #makeSASLog
   */</span>
  CommPortal.<span class="reserved">prototype</span>.makeSASErrorLog = <span class="reserved">function</span>(summary, details)
  {
    details += <span class="literal">"\nStack:\n"</span> + getStack(CommPortal.<span class="reserved">prototype</span>.makeSASErrorLog.caller);
    makeSASLogInternal(<span class="reserved">this</span>, true, summary, details);
  };

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> makeSASLogInternal(connection, isError, summary, details)
  {
    <span class="comment">// Only make a log if we have a session and the trimmed summary is not</span>
    <span class="comment">// blank.</span>
    <span class="reserved">if</span> (connection.sessionId &amp;&amp; (summary.replace(/^\s+|\s+$/g, <span class="literal">''</span>) != <span class="literal">""</span>))
    {
      var image = new Image();
      image.src = connection.server +
                  <span class="literal">"/session"</span> +
                  connection.sessionId +
                  <span class="literal">"/line/clientlog.gif?ContextInfo="</span> +
                  encodeURIComponent(getSASContextInfo(connection,
                                                       isError,
                                                       summary,
                                                       details));
    }
  };

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> getSASBasicContextInfo(connection)
  {
    <span class="comment">// Simply return a ContextInfo only containing the ClientVersion.</span>
    <span class="reserved">return</span> getSASContextInfo(connection, false, <span class="literal">""</span>, <span class="literal">""</span>);
  };

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> getSASContextInfo(connection, isError, summary, details)
  {
    <span class="comment">// Create a local function to truncate a message to a given length,</span>
    <span class="comment">// appending three dots (an ellipsis cannot be used until SAS supports</span>
    <span class="comment">// UTF-8).</span>
    var truncate = <span class="reserved">function</span>(message, length)
      {
        <span class="comment">// Trim whitespace.</span>
        message = message.replace(/^\s+|\s+$/g, <span class="literal">''</span>);
        <span class="reserved">if</span> (message.length &gt; length)
        {
          message = message.substr(0, length) + <span class="literal">"..."</span>;
        }
        <span class="reserved">return</span> message;
      };

    <span class="comment">// Truncate the fields so that the SAS database does not fill up too quickly.</span>
    var version = truncate(connection.clientVersion, 16);
    summary = truncate(summary, 128);
    details = truncate(details, 512);

    <span class="comment">// Only include the error, summary and details if there are any, since</span>
    <span class="comment">// otherwise SAS will use sensible defaults.</span>
    <span class="reserved">return</span>(<span class="literal">"version="</span> + encodeURIComponent(version) +
           (isError ? <span class="literal">"&amp;error=1"</span> : <span class="literal">""</span>) +
           ((summary.length &gt; 0) ? (<span class="literal">"&amp;summary="</span> + encodeURIComponent(summary)): <span class="literal">""</span>) +
           ((details.length &gt; 0) ? (<span class="literal">"&amp;details="</span> + encodeURIComponent(details)) : <span class="literal">""</span>));
  };

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> getStack(f)
  {
    var stack = <span class="literal">""</span>;
    try
    {
      <span class="reserved">if</span> (Error &amp;&amp; Error().stack)
      {
        <span class="comment">// Mozilla stores the stack directly on Error objects.</span>
        stack = Error().stack;

        <span class="comment">// Strip off the Error details and this function (the first 2 lines).</span>
        stack = /^.*\n.*\n([\s\S]*)$/.exec(stack)[1];

        <span class="comment">// The format of the stack is https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Error/stack</span>
        <span class="comment">// i.e. one line for each function with this format:</span>
        <span class="comment">// &lt;function name&gt;([parameters])@&lt;page URL&gt;:&lt;line number&gt;</span>
        <span class="comment">// Strip off the parameters and most of the page URL, otherwise there</span>
        <span class="comment">// will not be enough space in the 512 bytes details limit for much of</span>
        <span class="comment">// the stack.</span>
        <span class="comment">// (\S*\() - match on 0 or more non-white space chars, ending in open bracket.</span>
        <span class="comment">//           i.e. the function name and opening bracket.</span>
        <span class="comment">// .* - ignore 0 or more characters, i.e. any function parameters.</span>
        <span class="comment">// (\)) - match on closing bracket.</span>
        <span class="comment">// \@ - ignore @.</span>
        <span class="comment">// .* - ignore 0 or more characters.</span>
        <span class="comment">// \/ - ignore last / of URL.</span>
        <span class="comment">// ([^?#]*) - match on 1 or more non-?# characters, i.e. the last part of the URL.</span>
        <span class="comment">// [?#]* - ignore 0 or more ? and #, an optional URL parameter start or hash.</span>
        <span class="comment">// .* - ignore 0 or more characters.</span>
        <span class="comment">// (:\d*) - match the colon followed by the line number.</span>
        <span class="comment">//</span>
        <span class="comment">// Execute with multiline regexp so that the regexp matches on each line.</span>
        var functionsRegExp = /^(\S*\().*(\))\@.*\/([^?#]*)[?#]*.*(:\d*)$/gm;
        var matches;
        var cleanStack = <span class="literal">""</span>;
        <span class="reserved">while</span> (matches = functionsRegExp.exec(stack))
        {
          <span class="comment">// Prevent browsers like Firefox from getting stuck in an infinite loop</span>
          <span class="reserved">if</span> (matches.index == functionsRegExp.lastIndex)
          {
            functionsRegExp.lastIndex++;
          }
          <span class="comment">// The match results are stored from index 1 (index 0 is the expression</span>
          <span class="comment">// that the regexp operated on).</span>

          <span class="comment">// Make anonynous functions more obvious.</span>
          <span class="reserved">if</span> (matches[1] == <span class="literal">"("</span>)
          {
            matches[1] = <span class="literal">"anonymous("</span>;
          }

          <span class="reserved">for</span> (var ii = 1; ii &lt; matches.length; ii++)
          {
            cleanStack += matches[ii];
          }
          cleanStack += <span class="literal">"\n"</span>;
        }
        stack = cleanStack;
      }
      <span class="reserved">else</span> <span class="reserved">if</span> (f)
      {
        <span class="comment">// Extract the function name from the function.</span>
        var matches=/<span class="reserved">function</span> (\w+)/.exec(String(f));
        var stack = matches ? matches[1] : <span class="literal">""</span>;

        <span class="comment">// Get to the next depth in the stack.</span>
        stack += <span class="literal">"()\n"</span> + getStack(f.caller);
      }
      <span class="comment">// Otherwise we are at the end of stack so just return an empty string.</span>
    }
    catch (localException)
    {
      stack = <span class="literal">"Failed to get stack due to "</span> + localException;
    }

    <span class="reserved">return</span>(stack);
  };

  <span class="comment">/**
   * Class responsible for polling the CommPortal server for events
   * <span class="attrib">@class</span>
   * <span class="attrib">@private</span>
   */</span>
  <span class="reserved">function</span> CommPortalEvent()
  {
    <span class="comment">/**
     * This private variable stores the queue of events requests.
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.queuedEventRequests = [];

    <span class="comment">/**
     * This private variable stores the delay for the next poll.
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.delay = 0;

    <span class="comment">/**
     * This private variable stores the delay for the next poll if we got an
     * error.
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.nextErrorDelay = 0;

    <span class="comment">/**
     * This private variable stores the timeout for polling events.  Default
     * value set to 30000 milliseconds (30 seconds).
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.timeout = 30000;

    <span class="comment">/**
     * This private variable stores a list of events and their callbacks.
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.eventObjectList = [];

    <span class="comment">/**
     * This private variable stores the polling state.
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.pollingState = CommPortalEvent.STOPPED;

    <span class="comment">/**
     * This private variable stores the default subscriber line
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.defaultLine = <span class="literal">""</span>;

    <span class="comment">/**
     * This private variable stores the Class of Service data
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.classOfService = {};

    <span class="comment">/**
     * This private variable stores the mapping to convert the events name
     * that are exposed to the user to the events name used in the CommPortal
     * Server.
     * <span class="attrib">@private</span>
     */</span>
    <span class="reserved">this</span>.userToCommPortalEvents =
    {
      IncomingCallManager :         <span class="literal">"Meta_SubscriberDevice_MetaSphere_ICM"</span>,
      DoNotDisturb :                <span class="literal">"Meta_Subscriber_DoNotDisturb"</span>,
      FindMeFollowMe :              <span class="literal">"Meta_Subscriber_Find"</span>,
      UnconditionalCallForwarding : <span class="literal">"Meta_Subscriber_UnconditionalCallForwarding"</span>,
      VoicemailCount :              <span class="literal">"Meta_Subscriber_MetaSphere_VoicemailMessageCounts"</span>,
      Contacts :                    <span class="literal">"Meta_Subscriber_UC9000_Contacts"</span>,
      ClickToDialConfig :           <span class="literal">"Meta_SubscriberDevice_MetaSphere_CTDDeviceConfig"</span>,
      IncomingCall :                <span class="literal">"IncomingCall"</span>,
      Connection :                  <span class="literal">"Connection"</span>,
      <span class="comment">// Return an inverted version of this object making the keys be the</span>
      <span class="comment">// values and the values be the keys (only when the values are strings)</span>
      inverted : <span class="reserved">function</span>()
      {
        var result = {};
        <span class="comment">// For each key, invert it by the value</span>
        <span class="reserved">for</span> (var key in <span class="reserved">this</span>)
        {
          <span class="reserved">if</span> ((key in <span class="reserved">this</span>) &amp;&amp; typeof(<span class="reserved">this</span>[key]) == <span class="literal">"string"</span>)
          {
            <span class="comment">// Make the key be the value and the value be the key</span>
            result[<span class="reserved">this</span>[key]] = key;
          }
          <span class="reserved">else</span>
          {
            <span class="comment">// We cannot add a value as a key if it isn't o type string, but</span>
            <span class="comment">// we want to preserve it as it is in the original object</span>
            result[key] = <span class="reserved">this</span>[key];
          }
        }
        <span class="reserved">return</span> result;
      }
    };
  };

  <span class="comment">/**
   * State: Polling is stopped.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
   <span class="comment">/** <span class="attrib">@private</span> */</span>
  CommPortalEvent.STOPPED = 0;
  <span class="comment">/**
   * State: Polling is started.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
   <span class="comment">/** <span class="attrib">@private</span> */</span>
  CommPortalEvent.STARTED = 1;
  <span class="comment">/**
   * State: Polling is paused.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
   <span class="comment">/** <span class="attrib">@private</span> */</span>
  CommPortalEvent.PAUSED = 2;
  <span class="comment">/**
   * State: Polling is paused but wasn't started when paused.
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
   <span class="comment">/** <span class="attrib">@private</span> */</span>
  CommPortalEvent.PAUSED_NOT_STARTED = 3;
  <span class="comment">/**
   * Timeout to wait in addition to the default time out to identify
   * connection problem
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@final</span>
   */</span>
   <span class="comment">/** <span class="attrib">@private</span> */</span>
  CommPortalEvent.STANDARD_SERVER_TIMEOUT = 5000;

  <span class="comment">/**
   * Subscribe to events
   * <span class="attrib">@private</span>
   *
   * <span class="attrib">@see</span> CommPortal#subscribeToEvents
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.subscribeToEvents = <span class="reserved">function</span>(events,
                                                         eventCallback,
                                                         target,
                                                         timeout)
  {
    <span class="comment">// Check if there are any invalid or incompatible events specified</span>
    var error = <span class="reserved">this</span>.checkEventError(events, target);
    <span class="reserved">if</span> (!error)
    {
      <span class="comment">// Convert the events name to the ones used by CommPortal</span>
      var convertList = <span class="reserved">this</span>.userToCommPortalEvents;
      events = <span class="reserved">this</span>.convertEventName(events, convertList);

      <span class="comment">// Add the events to the list</span>
      <span class="reserved">this</span>.addEventList(events, eventCallback, target, timeout);

      <span class="comment">// Create the queue</span>
      <span class="reserved">this</span>.createQueue();

      <span class="reserved">if</span> (<span class="reserved">this</span>.pollNotStarted())
      {
        <span class="comment">// Start the polling</span>
        <span class="reserved">this</span>.pollForUpdates();
      }
    }

    <span class="reserved">return</span> error;
  };

  <span class="comment">/**
   * Unsubscribe from events
   * <span class="attrib">@private</span>
   *
   * <span class="attrib">@see</span> CommPortal#unsubscribeFromEvents
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.unsubscribeFromEvents = <span class="reserved">function</span>(events,
                                                             target)
  {
    var error = <span class="reserved">this</span>.removeEventList(events, target);
    <span class="reserved">this</span>.createQueue();
    <span class="reserved">return</span> error;
  };

  <span class="comment">/**
   * Poll for updates
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.pollForUpdates = <span class="reserved">function</span>()
  {
    <span class="reserved">if</span> (<span class="reserved">this</span>.pollingState == CommPortalEvent.STOPPED)
    {
      <span class="comment">// Change the polling state to started</span>
      <span class="reserved">this</span>.pollingState = CommPortalEvent.STARTED;
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span>.pollingState == CommPortalEvent.PAUSED_NOT_STARTED)
    {
      <span class="comment">// The polling is paused and wasn't started, so we change the state</span>
      <span class="comment">// to indicate that it should start after paused state finishes</span>
      <span class="reserved">this</span>.pollingState = CommPortalEvent.PAUSED;
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (!<span class="reserved">this</span>.hasEvents())
    {
      <span class="comment">// There aren't any events to poll, so stop polling</span>
      <span class="reserved">this</span>.pollingState = CommPortalEvent.STOPPED;
    }

    <span class="reserved">if</span> (<span class="reserved">this</span>.pollingState == CommPortalEvent.STARTED)
    {
      <span class="comment">// Take the next request off the queue</span>
      var eventObject = <span class="reserved">this</span>.queuedEventRequests.shift();

      <span class="comment">// and return it to the back of the queue again</span>
      <span class="reserved">this</span>.queuedEventRequests.push(eventObject);

      <span class="comment">// Create a uniquely named callback function for this request.</span>
      var callbackName = createUniqueId(<span class="literal">"callback"</span>);
      var callback = <span class="literal">"CommPortal."</span> + callbackName;

      <span class="reserved">this</span>.actualCallbackName = callbackName;

      <span class="comment">// Create the URL that we should send the request for events to on the</span>
      <span class="comment">// server</span>
      var eventURL = <span class="reserved">this</span>.createEventURL(eventObject, callback);

      var commportalEvent = <span class="reserved">this</span>;

      <span class="comment">// Register the uniquely-named callback</span>
      CommPortal[callbackName] = <span class="reserved">function</span>(data)
      {
        <span class="comment">// Call the getReponseCallback function if it is set.</span>
        <span class="reserved">if</span> (connection.getResponseCallback)
        {
          connection.getResponseCallback(callbackName,
                                         null,
                                         <span class="literal">"event.js"</span>,
                                         data,
                                         null,
                                         null,
                                         null);
        }

        <span class="comment">// Handle the response</span>
        commportalEvent.handleEventResponse(data);

        <span class="comment">// Cleanup the callback and script tag</span>
        commportalEvent.cleanupRequest(callbackName, scriptTag);

        <span class="comment">// Clear the script timeout</span>
        clearTimeout(handleTimeout);
      };

      <span class="comment">// Append the script tag to poll for events</span>
      var scriptTag = appendScriptTag(eventURL);

      <span class="reserved">this</span>.actualScriptTag = scriptTag;

      <span class="comment">// Will handle any connection problem that could have occurred</span>
      <span class="reserved">function</span> handleScriptRequestTimeout()
      {
        <span class="comment">// We had a problem with the script request, cleanup the callback and</span>
        <span class="comment">// script tab</span>
        commportalEvent.cleanupRequest(callbackName, scriptTag);

        <span class="reserved">if</span> (commportalEvent.pollingState == CommPortalEvent.STARTED)
        {
          <span class="comment">// Poll for updates</span>
          commportalEvent.pollForUpdates();
        }
      }

      <span class="comment">// Set a timeout to handle a connection problem in the request</span>
      var handleTimeout =
            setTimeout(handleScriptRequestTimeout,
                       <span class="reserved">this</span>.timeout + CommPortalEvent.STANDARD_SERVER_TIMEOUT);

      <span class="comment">// Call the getRequestCallback function if it is set.</span>
      <span class="reserved">if</span> (connection.getRequestCallback)
      {
        connection.getRequestCallback(eventURL);
      }
    }
  };

  <span class="comment">/**
   * Pause polling
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.pausePolling = <span class="reserved">function</span>()
  {
    <span class="reserved">if</span> (<span class="reserved">this</span>.pollingState == CommPortalEvent.STARTED)
    {
      <span class="comment">// The polling was already started, so we indicate that it is paused now</span>
      <span class="comment">// but should be started again.</span>
      <span class="reserved">this</span>.pollingState = CommPortalEvent.PAUSED;
      <span class="comment">// Cancel and clear any outstanding request</span>
      <span class="reserved">this</span>.cleanupRequest(<span class="reserved">this</span>.actualCallbackName, <span class="reserved">this</span>.actualScriptTag);
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span>.pollingState == CommPortalEvent.STOPPED)
    {
      <span class="comment">// The polling was stopped, so we indicate that it is paused now but</span>
      <span class="comment">// wasn't started yet</span>
      <span class="reserved">this</span>.pollingState = CommPortalEvent.PAUSED_NOT_STARTED;
    }
  };

  <span class="comment">/**
   * Restart polling if it was started before being paused
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.restartPolling = <span class="reserved">function</span>()
  {
    <span class="reserved">if</span> (<span class="reserved">this</span>.pollingState == CommPortalEvent.PAUSED)
    {
      <span class="comment">// The polling was paused and now it needs to be started again</span>
      <span class="reserved">this</span>.pollingState = CommPortalEvent.STARTED;
      <span class="reserved">this</span>.pollForUpdates();
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span>.pollingState == CommPortalEvent.PAUSED_NOT_STARTED)
    {
      <span class="comment">// The polling was paused but there is no need to start it again</span>
      <span class="reserved">this</span>.pollingState = CommPortalEvent.STOPPED;
    }
  };

  <span class="comment">/**
   * Return true if the poll has not started
   * <span class="attrib">@return</span> true if poll not started
   * <span class="attrib">@type</span> boolean
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.pollNotStarted = <span class="reserved">function</span>()
  {
    var result = ((<span class="reserved">this</span>.pollingState == CommPortalEvent.STOPPED) ||
                  (<span class="reserved">this</span>.pollingState == CommPortalEvent.PAUSED_NOT_STARTED));

    <span class="reserved">return</span> result;
  };

  <span class="comment">/**
   * Handle the event response
   *
   * <span class="attrib">@param</span> {Object} data contents of JSON service indication
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.handleEventResponse = <span class="reserved">function</span>(data)
  {
    <span class="reserved">this</span>.delay = 0;
 
    <span class="comment">// We need to call the callback for any data that we have been told has</span>
    <span class="comment">// changed</span>
    var eventList = data.events;
    <span class="reserved">if</span> (eventList)
    {
      <span class="reserved">for</span> (var i = 0; i &lt; eventList.length; i++)
      {
        var event = eventList[i];
        var eventName = event.subscription;
        var target = event.objectIdentity.line;
        
        <span class="comment">// Get the callback responsible for handling the event</span>
        var callback = <span class="reserved">this</span>.getEventCallback(eventName, target);
        <span class="reserved">if</span> (callback)
        {
          <span class="comment">// Convert the event name to the one used by the user</span>
          var convertList = <span class="reserved">this</span>.userToCommPortalEvents.inverted();
          eventName = (<span class="reserved">this</span>.convertEventName(eventName, convertList))[0];
          queueCallback(callback,
                        connection,
                        target,
                        eventName,
                        event.data,
                        event.eventType);
        }
      }
    }

    var errorList = data.errors;
    <span class="reserved">if</span> (errorList.length &gt; 0)
    {
      <span class="comment">// Since we are getting errors, we delay before our next poll</span>
      <span class="comment">// However, if we are getting noSuchObject, we should not ask again, per the API.</span>
      <span class="reserved">this</span>.delay = (type == <span class="literal">"noSuchObject"</span>) ? -1 : <span class="reserved">this</span>.getNextErrorDelay();
    }

    <span class="comment">// A non-negative delay means we should poll again</span>
    <span class="reserved">if</span> (<span class="reserved">this</span>.delay &gt;= 0)
    {
      var commportalEvent = <span class="reserved">this</span>;
      setTimeout(<span class="reserved">function</span>()
      {
        commportalEvent.pollForUpdates();
      }, <span class="reserved">this</span>.delay);
    }
  };

  <span class="comment">/**
   * Return the delay that should be used if we got an error
   *
   * <span class="attrib">@return</span> the delay in milliseconds
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.getNextErrorDelay = <span class="reserved">function</span>()
  {
    var delay = <span class="reserved">this</span>.nextErrorDelay || 0;

    <span class="comment">// Update the nextErrorDelay so we delay increasingly larger gaps</span>
    <span class="comment">// when errors are occuring continuously, up to a maximum of 30 secs</span>
    <span class="reserved">this</span>.nextErrorDelay = Math.min(30000, delay * 2 + 2000);

    <span class="reserved">return</span> delay;
  };

  <span class="comment">/**
   * Convert the event name in the event list acconding to the convert list
   *
   * The event name will be preserved if there isn't a corresponding one in
   * the convert list.
   *
   * <span class="attrib">@param</span> {String/String[]} eventList events that we should convert
   * <span class="attrib">@param</span> {Object} convertList a map with the events name
   *
   * <span class="attrib">@return</span> the new event list with the event names converted
   * <span class="attrib">@type</span> Array
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.convertEventName = <span class="reserved">function</span>(eventList, convertList)
  {
    <span class="comment">// Ensure we are manipulating an array</span>
    eventList = toArray(eventList);

    var result = [];

    <span class="comment">// For each event in the list, check if there is the corresponding one in</span>
    <span class="comment">// the convert list</span>
    <span class="reserved">for</span> (var i = 0; i &lt; eventList.length; i++)
    {
      var event = eventList[i];
      <span class="reserved">if</span> (event in convertList)
      {
        <span class="comment">// Convert the event name and add it to the list</span>
        result.push(convertList[event]);
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// We also add the ones that were not found in the convert list</span>
        result.push(event);
      }
    }

    <span class="reserved">return</span> result;
  };

  <span class="comment">/**
   * Fetch some required data for the events
   *
   * &lt;p&gt;
   * We are interested in the Class of Service and Subscriber number.
   * The Class of Service will be used to check if the user is allowed to
   * listen to an specific event.  The subscriber number is used to identify
   * events for the default subscriber number.
   *
   * <span class="attrib">@param</span> callback the callback called after we finished retrieving the data
   *   from the server
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.fetchRequiredData = <span class="reserved">function</span>(connection, callback)
  {
    var commPortalEvent = <span class="reserved">this</span>;
    var requiredData =
    {
      cos     : <span class="literal">"Meta_Subscriber_MetaSphere_ClassOfService"</span>,
      session : <span class="literal">"Session"</span>
    };

    commonFetchRequiredData(requiredData, connection, processData);

    <span class="reserved">function</span> processData()
    {
      commPortalEvent.classOfService = connection.cache.cos;
      <span class="reserved">if</span> (connection.cache.session.ManagedSubscribers[0])
      {
        commPortalEvent.defaultLine =
                connection.cache.session.ManagedSubscribers[0].DirectoryNumber;
      }
      <span class="comment">// Call the callback</span>
      callback();
    }
  };

  <span class="comment">/**
   * Return true if we have events in the queue
   *
   * <span class="attrib">@return</span> true if we have request queued
   * <span class="attrib">@type</span> boolean
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.hasEvents = <span class="reserved">function</span>()
  {
    <span class="reserved">return</span> <span class="reserved">this</span>.queuedEventRequests.length &gt; 0;
  };

  <span class="comment">/**
   * Check if we can listen to the events checking the Class of Service to
   * see if we are allowed and if there isn't any incompatible events to be
   * listen for
   *
   * <span class="attrib">@param</span> {String/String[]} eventList events that we should check
   * <span class="attrib">@param</span> {String} target line number to request events on
   * <span class="attrib">@return</span> an error if the events are not allowed to be listened for or if
   *   there is an incompatible event to listen to or undefined if not
   * <span class="attrib">@type</span> error
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.checkEventError = <span class="reserved">function</span>(eventList, target)
  {
    <span class="comment">// Check if we don't have any not allowed event to be listen</span>
    var error = <span class="reserved">this</span>.checkEventNotAllowed(eventList);

    <span class="reserved">if</span> (!error)
    {
      <span class="comment">// Check if we don't have any incompatible event to be listened for</span>
      error = <span class="reserved">this</span>.checkEventIncompatible(eventList, target);
    }

    <span class="reserved">return</span> error;
  };

  <span class="comment">/**
   * Check if the subscriber is allowed to listen to the events
   *
   * Note that the event name used here are the ones that are exposed to the
   * user and not the ones that are used by the CommPortal.
   *
   * <span class="attrib">@param</span> {String/String[]} eventList the events that we should check
   * <span class="attrib">@return</span> an error indicating that the subscriber is not allowed to listen
   *   to one or more events or undefined if the subscriber is allowed
   * <span class="attrib">@type</span> error
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.checkEventNotAllowed = <span class="reserved">function</span>(eventList)
  {
    eventList = toArray(eventList);
    var eventNotAllowed = [];
    <span class="reserved">for</span> (var i in eventList)
    {
      <span class="reserved">if</span> (eventList.hasOwnProperty(i))
      {
        <span class="comment">// Get the related CoS service that we should check</span>
        var cosService = getService(eventList[i]);
        <span class="reserved">if</span> ((cosService) &amp;&amp;
            (<span class="reserved">this</span>.classOfService[cosService.service] != cosService.value))
        {
          <span class="comment">// We are not allowed to listen to the event</span>
          eventNotAllowed.push(eventList[i]);
        }
      }
    }

    <span class="comment">// Get the related event CoS service and value</span>
    <span class="reserved">function</span> getService(event)
    {
      var service = null;
      var value = null;
      switch (event)
      {
      case <span class="literal">"IncomingCall"</span>:
        service = <span class="literal">"IcpAllowed"</span>;
        value   = true;
        break;
      case <span class="literal">"IncomingCallManager"</span>:
        service = <span class="literal">"IcmAllowed"</span>;
        value   = true;
        break;
      }

      var cosService = null;
      <span class="reserved">if</span> (service &amp;&amp; value)
      {
        var cosService =
        {
          service : service,
          value   : value
        };
      }

      <span class="reserved">return</span> cosService;
    }

    var result = undefined;
    <span class="reserved">if</span> (eventNotAllowed.length &gt; 0)
    {
      <span class="comment">// Create the error indicating that there are one or more events that</span>
      <span class="comment">// the subscriber is not allowed to listen for</span>
      result = new CommPortalError(CommPortal.ERROR_SUBSCRIPTION_NOT_ALLOWED,
                                   {events : eventNotAllowed});
    }

    <span class="reserved">return</span> result;
  };

  <span class="comment">/**
   * Return an error if the events are incompatible to the ones that are
   * already being listened for or undefined if the events are compatible.
   *
   * <span class="attrib">@param</span> {String/String[]} eventList which events should be checked
   * <span class="attrib">@param</span> {String} target line number to request events on
   *
   * <span class="attrib">@return</span> an error if the events are incompatible or undefined if not
   * <span class="attrib">@type</span> error
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.checkEventIncompatible = <span class="reserved">function</span>(eventList,
                                                              target)
  {
    <span class="comment">// Set the target if it isn't defined and ensure we are manipulating an</span>
    <span class="comment">// array</span>
    target = <span class="reserved">this</span>.normalizeTarget(target);
    eventList = toArray(eventList);

    var result = undefined;

    <span class="comment">// We can only have problems when listen to IncomingCall</span>
    var incompatibleEvent = <span class="literal">"IncomingCall"</span>;

    <span class="comment">// Check if the item is on the list</span>
    <span class="reserved">function</span> checkList(item, list)
    {
      var result = false;
      <span class="reserved">for</span> (var i = 0; i &lt; list.length; i++)
      {
        <span class="reserved">if</span> (list[i] == item)
        {
          result = true;
          break;
        }
      }
      <span class="reserved">return</span> result;
    }

    <span class="comment">// Check if there is any incompatible event on event List</span>
    var iCOnEventList = checkList(incompatibleEvent, eventList);

    <span class="comment">// Check if there is any incompatible event on queued events</span>
    var iCOnQueueEvent = false;
    var queueTargetList = [];
    <span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.queuedEventRequests.length; i++)
    {
      var queuedEvent = <span class="reserved">this</span>.queuedEventRequests[i];
      <span class="comment">// Check if there is an incompatible event on the queue</span>
      iCOnQueueEvent = (iCOnQueueEvent ||
                        checkList(incompatibleEvent, queuedEvent.events));
      <span class="comment">// Save all targets line</span>
      queueTargetList.push(queuedEvent.target);
    }

    <span class="reserved">if</span> ((iCOnEventList &amp;&amp; queueTargetList.length &gt; 1) ||
        ((iCOnEventList &amp;&amp; queueTargetList.length == 1) &amp;&amp;
         (queueTargetList[0] != target)) ||
        (!iCOnEventList &amp;&amp; iCOnQueueEvent &amp;&amp; queueTargetList[0] != target))
    {
      <span class="comment">// We return the incompatible event error for one of the following three</span>
      <span class="comment">// possibilities.</span>
      <span class="comment">// We have Incoming Call on eventList and we are listening to more than</span>
      <span class="comment">// one target line.</span>
      <span class="comment">// We have Incoming Call on eventList and the target line that we are</span>
      <span class="comment">// listening to events on is different from the new target</span>
      <span class="comment">// We are listening for Incoming Call and the new target is different</span>
      <span class="comment">// from the target for the Incoming Call</span>
      result = new CommPortalError(CommPortal.ERROR_INCOMPATIBLE_EVENTS);
    }

    <span class="reserved">return</span> result;
  };

  <span class="comment">/**
   * Set the maximum timeout used on the request for events
   *
   * <span class="attrib">@param</span> {Integer} timeout [optional] maximum timeout to use in milliseconds
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.setRequestTimeout = <span class="reserved">function</span>(timeout)
  {
    <span class="reserved">if</span> (timeout &amp;&amp; timeout &gt;= 0)
    {
      <span class="reserved">this</span>.timeout = timeout;
    }
  };

  <span class="comment">/**
   * Set the target to the subscriber line number if it is undefined
   *
   * <span class="attrib">@param</span> {String} target [optional] line number
   * <span class="attrib">@return</span> the subscriber line if the target was undefined or the target
   *   unmodified if not
   * <span class="attrib">@type</span> String
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.normalizeTarget = <span class="reserved">function</span>(target)
  {
    <span class="reserved">return</span> target ? target : <span class="reserved">this</span>.defaultLine;
  };

  <span class="comment">/**
   * Set the target to an empty string if the target is the subscriber line
   * number
   *
   * <span class="attrib">@param</span> {String} target line number
   * <span class="attrib">@return</span> the target line as an empty string if the target is equal to the
   *   subscriber line or the target unmodified if not
   * <span class="attrib">@type</span> String
   * <span class="attrib">@private</span>
   */</span>
   CommPortalEvent.<span class="reserved">prototype</span>.unnormalizeTarget = <span class="reserved">function</span>(target)
   {
     <span class="reserved">return</span> target == <span class="reserved">this</span>.defaultLine ? <span class="literal">""</span> : target;
   };

  <span class="comment">/**
   * Get the index of the event in the eventObjectList
   *
   * <span class="attrib">@param</span> {String} event the event name
   * <span class="attrib">@param</span> {String} target line number
   * <span class="attrib">@return</span> the event index or -1 if not found
   * <span class="attrib">@type</span> integer
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.getEventIndex = <span class="reserved">function</span>(event, target)
  {
    var result = -1;

    <span class="comment">// Iterate through the event object list to find its position</span>
    <span class="reserved">for</span> (var index = 0; index &lt; <span class="reserved">this</span>.eventObjectList.length; index++)
    {
      var eventObject = <span class="reserved">this</span>.eventObjectList[index];
      <span class="reserved">if</span> (eventObject.event == event &amp;&amp; eventObject.target == target)
      {
        <span class="comment">// We found the event, so stop looking for it</span>
        result = index;
        break;
      }
    }

    <span class="reserved">return</span> result;
  };

  <span class="comment">/**
   * Get the callback associated with the event
   *
   * <span class="attrib">@param</span> {String} event the event name
   * <span class="attrib">@param</span> {String} target line number
   * <span class="attrib">@return</span> the event callback
   * <span class="attrib">@type</span> Function
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.getEventCallback = <span class="reserved">function</span>(event, target)
  {
    var callback = null;
    <span class="comment">// Get the index of the event in our list</span>
    var index = <span class="reserved">this</span>.getEventIndex(event, target);
    <span class="reserved">if</span> (index &gt;= 0 &amp;&amp; index &lt; <span class="reserved">this</span>.eventObjectList.length)
    {
      <span class="comment">// Get the callback of the event</span>
      var callback = <span class="reserved">this</span>.eventObjectList[index].callback;
    }

    <span class="reserved">return</span> callback;
  };

  <span class="comment">/**
   * Remove the events from the eventObjectList
   *
   * <span class="attrib">@param</span> {String/String[]} eventList which events we should remove
   * <span class="attrib">@param</span> {String} target [optional] line number
   *
   * <span class="attrib">@return</span> undefined on success or an error if one of the events on the
   *   eventList was not found
   * <span class="attrib">@type</span> error
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.removeEventList = <span class="reserved">function</span>(eventList, target)
  {
    <span class="comment">// Ensure that we are manipulating an array</span>
    eventList = toArray(eventList);

    var eventsNotFound = [];

    <span class="comment">// Normalize the target to a valid value as it can be undefined</span>
    target = <span class="reserved">this</span>.normalizeTarget(target);

    <span class="comment">// Iterate through the event list and remove all of them</span>
    <span class="reserved">for</span> (var i = 0; i &lt; eventList.length; i++)
    {
      var event = eventList[i];

      <span class="comment">// Get the index of the event on our list</span>
      var index = <span class="reserved">this</span>.getEventIndex(event, target);

      <span class="reserved">if</span> (index &gt; -1)
      {
        <span class="comment">// Remove the event from the list</span>
        <span class="reserved">this</span>.eventObjectList.splice(index, 1);
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// Add the event to the not found list</span>
        eventsNotFound.push(event);
      }
    }

    var result = undefined;
    <span class="reserved">if</span> (eventsNotFound.length &gt; 0)
    {
      <span class="comment">// We didn't find one or more events to remove</span>
      result = new CommPortalError(CommPortal.ERROR_NO_CORRESPONDING_HANDLER,
                                   {events : eventsNotFound});
    }

    <span class="reserved">return</span> result;
  };

  <span class="comment">/**
   * Add the events and their callback to the eventObjectList.
   *
   * <span class="attrib">@param</span> {String/String[]} eventList which events we should subscribe to
   * <span class="attrib">@param</span> {function} eventCallback callback called for each event
   * <span class="attrib">@param</span> {String} target [optional] line number
   * <span class="attrib">@param</span> {Integer} timeout [optional] maximum timeout to use
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.addEventList = <span class="reserved">function</span>(eventList,
                                                    eventCallback,
                                                    target,
                                                    timeout)
  {
    <span class="comment">// Ensure that we are manipulating an array</span>
    eventList = toArray(eventList);

    <span class="comment">// Normalize the target to a valid value as it can be undefined</span>
    target = <span class="reserved">this</span>.normalizeTarget(target);

    <span class="comment">// Set the new timeout, if valid</span>
    <span class="reserved">this</span>.setRequestTimeout(timeout);

    <span class="comment">// Add all events to our events list</span>
    <span class="reserved">for</span> (var i = 0; i &lt; eventList.length; i++)
    {
      var event = eventList[i];

      <span class="comment">// Remove any existent event with the same name</span>
      <span class="reserved">this</span>.removeEventList(event, target);

      <span class="comment">// Create the new event and add it to our list</span>
      var newEventObject =
      {
        event : event,
        callback : eventCallback,
        target : target
      };
      <span class="reserved">this</span>.eventObjectList.push(newEventObject);
    }
  };

  <span class="comment">/**
   * Create the queue to poll the server for events merging events for the same
   * target
   *
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.createQueue = <span class="reserved">function</span>()
  {
    <span class="reserved">this</span>.queuedEventRequests = [];

    <span class="comment">// Group the events by target</span>
    var targets = {};
    <span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.eventObjectList.length; i++)
    {
      var eventObject = <span class="reserved">this</span>.eventObjectList[i];

      <span class="reserved">if</span> (targets[eventObject.target])
      {
        <span class="comment">// Target already exists, just add the event to the list</span>
        targets[eventObject.target].push(eventObject.event);
      }
      <span class="reserved">else</span>
      {
        <span class="comment">// New target found, create an instance of the target</span>
        targets[eventObject.target] = [eventObject.event];
      }
    }

    <span class="comment">// Queue all events for the same target</span>
    <span class="reserved">for</span> (var key in targets)
    {
      <span class="reserved">if</span> (targets.hasOwnProperty(key))
      {
        var eventQueued =
        {
          target: key,
          events: targets[key]
        };

        <span class="reserved">this</span>.queuedEventRequests.push(eventQueued);
      }
    }
  };

  <span class="comment">/**
   * Create the URL that will be used to poll the server for events
   *
   * <span class="attrib">@param</span> {Object} eventQueued event object from the queue
   * <span class="attrib">@param</span> {function} callback the callback that will be called by the data
   *   returned from the server request
   * <span class="attrib">@return</span> the URL to use in the resquest
   * <span class="attrib">@type</span> String
   *
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.createEventURL = <span class="reserved">function</span>(eventQueued, callback)
  {
    <span class="comment">// We have some events we are interested in.</span>
    var eventURL = <span class="literal">"events?events="</span> + eventQueued.events.join(<span class="literal">","</span>);

    <span class="comment">// Timeout is OPTIONAL but server currently requires it</span>
    eventURL += <span class="literal">"&amp;timeout="</span> + <span class="reserved">this</span>.timeout;

    <span class="comment">// We must always give the version number</span>
    eventURL += <span class="literal">"&amp;version="</span> + connection.interfaceVersion;

    <span class="comment">// We must always give a callback</span>
    eventURL += <span class="literal">"&amp;callback="</span> + callback;

    <span class="comment">// Set the call if this is a connection subscription and there is a call</span>
    <span class="comment">// ID.</span>
    var callId = connection.getCallId();

    <span class="reserved">if</span> ((eventQueued.events[0] == <span class="literal">"Connection"</span>) &amp;&amp; (callId != null))
    {
      eventURL = <span class="literal">"call"</span> + callId + <span class="literal">"/"</span> + eventURL;
    }

    <span class="comment">// Set the target line</span>
    var target = <span class="reserved">this</span>.unnormalizeTarget(eventQueued.target);
    eventURL = <span class="literal">"line"</span> + target + <span class="literal">"/"</span> + eventURL;

    <span class="comment">// Create the session URL</span>
    var sessionURL = connection.server + <span class="literal">"/session"</span> + connection.sessionId;
    eventURL = sessionURL + <span class="literal">"/"</span> + eventURL;

    <span class="reserved">return</span> eventURL;
  };

  <span class="comment">/**
   * Cleanup any outstanding request removing the callback and the tag script
   *
   * <span class="attrib">@param</span> {String} callbackName name of the callback that we should clean
   * <span class="attrib">@param</span> {Object} scriptTag the html script tag to be removed
   * <span class="attrib">@private</span>
   */</span>
  CommPortalEvent.<span class="reserved">prototype</span>.cleanupRequest = <span class="reserved">function</span>(callbackName, scriptTag)
  {
    var timeoutHandle;
    <span class="reserved">function</span> cleanupFunction()
    {
      try
      {
        <span class="comment">// Get rid of this function</span>
        delete CommPortal[callbackName];
      }
      catch (exception)
      {
        <span class="comment">// Fails in IE 6, just null out instead.</span>
        CommPortal[callbackName] = undefined;
      }

      clearTimeout(timeoutHandle);
    }
    CommPortal[callbackName] = cleanupFunction;

    <span class="comment">// Schedule a timer to clear it up completely in a minute's time.  If the</span>
    <span class="comment">// request did take longer than this then all that happens is we get a</span>
    <span class="comment">// benign JS error.</span>
    timeoutHandle = setTimeout(cleanupFunction, 60 * 1000);

    <span class="comment">// Try to force the browser to cancel any outstanding request for the</span>
    <span class="comment">// script file by removing it from the DOM.  We also tried changing the</span>
    <span class="comment">// src to null, but this fails in IE, which requests "null" from the</span>
    <span class="comment">// server.</span>
    <span class="reserved">if</span> (scriptTag)
    {
      <span class="comment">// Remove the src attribute, which stops any outstanding browser request</span>
      scriptTag.removeAttribute(<span class="literal">"src"</span>);

      <span class="comment">// The element hasn't been cleaned up yet</span>
      var parent = scriptTag.parentNode;
      <span class="reserved">if</span> (parent)
      {
        parent.removeChild(scriptTag);
      }
    }
  };

  <span class="comment">// Private methods</span>
  <span class="comment">// Unfortunately due to a bug in jsDoc, we need to explictly mark these all</span>
  <span class="comment">// as private to avoid them showing up as GLOBAL functions (which they most</span>
  <span class="comment">// definitely are not)</span>

  <span class="comment">/**
   * Takes a URL and parses out the query string, returning it as an object
   * mapping keys to values.
   */</span>
  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> parseQueryStringParams(url)
  {
    var hashIdx = url.indexOf(<span class="literal">"#"</span>);
    var params = {};

    <span class="reserved">if</span> (hashIdx != -1)
    {
      url = url.substring(0, hashIdx);
    }
    var qsIdx = url.indexOf(<span class="literal">"?"</span>);
    <span class="reserved">if</span> (qsIdx != -1)
    {
      <span class="comment">// Got a query string, extract it</span>
      var qs = url.substring(qsIdx + 1);

      <span class="comment">// Split on &amp;</span>
      var splits = qs.split(<span class="literal">"&amp;"</span>);

      <span class="comment">// Spin over the key-value pairs, adding to the result</span>
      <span class="reserved">for</span> (var i = 0; i &lt; splits.length; i++)
      {
        var keyValue = splits[i];

        var keyValueArray = keyValue.match(/([^=]*)=(.*)/);
        <span class="reserved">if</span> (keyValueArray)
        {
          params[keyValueArray[1]] = keyValueArray[2];
        }
      }
    }

    <span class="reserved">return</span> params;
  }

  <span class="comment">/**
   * Convert the object form of object ID to the string form for use in a data
   * request.
   *
   * <span class="attrib">@param</span> objectIdentity
   *          The object-form object identity to convert.
   * <span class="attrib">@return</span> the string form of the the object identity.
   * <span class="attrib">@type</span> String
   */</span>
  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> objectIdentityToString(objectIdentity)
  {
    var string = <span class="literal">""</span>;

    <span class="reserved">if</span> (objectIdentity)
    {
      var properties = [];
      <span class="reserved">for</span> (var prop in objectIdentity)
      {
        properties.push(prop + <span class="literal">"="</span> + objectIdentity[prop]);
      }
      string = properties.join(<span class="literal">"&amp;"</span>);
    }

    <span class="reserved">return</span> string;
  }

  <span class="comment">/**
   * Create a new unique ID for use in naming generated elements etc.
   *
   * <span class="attrib">@param</span> {String}
   *          base An ID-safe string used as part of the output ID. e.g. "iFrame"
   *          would be a good base when naming an iFrame.
   * <span class="attrib">@return</span> An ID-safe string that is very likely to be unique.
   * <span class="attrib">@type</span> String
   */</span>
  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> createUniqueId(base)
  {
    <span class="reserved">return</span> <span class="literal">"CommPortal_"</span> + base + <span class="literal">"_"</span> + sUniqueId++;
  }

  <span class="comment">/**
   * Removes the specified element from the page.
   *
   * <span class="attrib">@param</span> {Element} element The element to remove (may be undefined)
   */</span>
  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> removeElement(element)
  {
    <span class="reserved">if</span> (element)
    {
      var parent = element.parentNode;
      <span class="reserved">if</span> (parent)
      {
        parent.removeChild(element);
      }
    }
  }

  <span class="comment">/**
   * Append a script tag to the page.
   *
   * Stored in a variable to allow it to be more easily replaced for testing.
   */</span>
  <span class="comment">/** <span class="attrib">@private</span> */</span>
  var appendScriptTag = <span class="reserved">function</span>(url)
  {
    var scriptTag = document.createElement(<span class="literal">"script"</span>);
    scriptTag.setAttribute(<span class="literal">"src"</span>, url);
    scriptTag.setAttribute(<span class="literal">"type"</span>, <span class="literal">"text/javascript"</span>);
    document.body.appendChild(scriptTag);

    <span class="reserved">return</span> scriptTag;
  };

  <span class="comment">/**
   * Flattens the data object, to make this much more like a standard
   * javascript object, and less like the representation of an XML data
   * structure that is ultimately is.
   */</span>
  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> flattenDataObject(obj, dataType)
  {
    <span class="comment">// We are more thorough in checking for an array than you might expect.</span>
    <span class="comment">// This is because we expect to run in the presence of other libraries, or</span>
    <span class="comment">// simply other code, and javascript allows objects to be augmeted in ways</span>
    <span class="comment">// you would not expect</span>
    <span class="reserved">if</span> (Object.<span class="reserved">prototype</span>.toString.apply(obj) === <span class="literal">"[object Array]"</span>)
    {
      <span class="comment">// This object is an array - so flatten each item</span>
      var flat = [];

      <span class="reserved">for</span> (var i = 0; i &lt; obj.length; i++)
      {
        flat.push(flattenDataObject(obj[i], dataType));
      }
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// This is an object, so flatten each of its fields</span>
      var flat = {};
      <span class="reserved">for</span> (var field in obj)
      {
        <span class="reserved">if</span> (obj.hasOwnProperty(field))
        {
          <span class="reserved">if</span> (field == <span class="literal">"_"</span>)
          {
            <span class="comment">// The field uses the _ convention</span>
            flat = obj[field];
          }
          <span class="reserved">else</span>
          {
            <span class="comment">// The default is that we use the same name in the flat version</span>
            var outfield = field;

            <span class="reserved">if</span> (outfield[0] == <span class="literal">"_"</span>)
            {
              <span class="comment">// The name starts with a awkward underscore - discard it</span>
              outfield = outfield.substring(1);
            }

            <span class="reserved">if</span> (outfield == outfield.toUpperCase() &amp;&amp;
                !outfield.match(<span class="literal">"^(MADN|HTTP|SIP|URL)$"</span>))
            {
              <span class="comment">// The fieldname is UGLY CAPS and not a known acronym, so change</span>
              <span class="comment">// it to an easier to read Initial Caps.</span>
              outfield = outfield.charAt(0) + outfield.substring(1).toLowerCase();
            }

            <span class="reserved">if</span> (obj[field]._ !== undefined)
            {
              <span class="comment">// This field has a value, so use that value</span>
              flat[outfield] = obj[field]._;
            }
            <span class="reserved">else</span> <span class="reserved">if</span> (obj[field].Value &amp;&amp; obj[field].Value._ !== undefined)
            {
              <span class="comment">// This object has a default and value, so just use the value</span>
              flat[outfield] = obj[field].Value._;
            }
            <span class="reserved">else</span> <span class="reserved">if</span> (obj[field] !== null &amp;&amp; typeof obj[field] === <span class="literal">"object"</span>)
            {
              <span class="comment">// Some object, handled recursively</span>
              flat[outfield] = flattenDataObject(obj[field], dataType);
            }
            <span class="reserved">else</span> <span class="reserved">if</span> (typeof obj[field] !== <span class="literal">"function"</span>)
            {
              <span class="comment">// Simple field</span>
              flat[outfield] = obj[field];
            }
          }
        }
      }
    }

    <span class="reserved">return</span> flat;
  }

  <span class="comment">/**
   * Handles some special cases where the wire format is particularly poor.
   */</span>
  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> handleSpecialCases(dataType, data)
  {
    <span class="reserved">if</span> (dataType == <span class="literal">"Meta_Subscriber_MetaSphere_SubscriberCapabilities"</span>)
    {
      <span class="comment">// Subscriber caps is an array of objects each containing a Name and a</span>
      <span class="comment">// Value - so we convert them into a single object, with each</span>
      <span class="comment">// name being a property of that object - far easier to work with!</span>
      var newData = {};

      <span class="reserved">for</span> (var i = 0; i &lt; data.length; i++)
      {
        var name = data[i].Name;
        var value = data[i].Value;

        <span class="comment">// Remove any redundant "dcl" prefix from the name</span>
        <span class="reserved">if</span> (name.substring(0,3) == <span class="literal">"dcl"</span>)
        {
          name = name.substring(3);
        }

        <span class="comment">// Treat string representation of boolean concepts as real booleans</span>
        value = (value == <span class="literal">"true"</span>) ? true :
                (value == <span class="literal">"false"</span>) ? false :
                value;

        newData[name] = value;
      }

      data = newData;
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (dataType == <span class="literal">"Meta_Subscriber_CallLists"</span> ||
             dataType == <span class="literal">"Meta_Subscriber_MetaSphere_CallList"</span>)
    {
      <span class="comment">// Call lists have duration given as a display 00:00:00 form, but it's</span>
      <span class="comment">// much better to have these as a number of seconds</span>
      <span class="comment">// NB. Missed calls do not have a duration, so we don't look for those.</span>
      var names = [<span class="literal">"DialedCalls"</span>,
                   <span class="literal">"AnsweredCalls"</span>,
                   <span class="literal">"RejectedCalls"</span>];
      <span class="reserved">for</span> (var i = 0; i &lt; names.length; i++)
      {
        var calls = data[names[i]];
        <span class="reserved">if</span> (calls)
        {
          calls = calls.Call;
          <span class="reserved">if</span> (calls)
          {
            <span class="reserved">for</span> (var c = 0; c &lt; calls.length; c++)
            {
              var asText = calls[c].Duration;
              var parts = asText.split(<span class="literal">":"</span>);
              var duration = (parseInt(parts[0], 10) * 60 * 60) +
                             (parseInt(parts[1], 10) * 60) +
                             parseInt(parts[2], 10);

              calls[c].Duration = duration;
            }
          }
        }
      }
    }

    <span class="reserved">return</span> data;
  }

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> createiFrame(id)
  {
    <span class="comment">// If we create an iframe via createElement then we don't seem to be able</span>
    <span class="comment">// to set the "name" attribute properly, so we do it the indirect way</span>
    <span class="comment">// via innerHTML</span>
    var outer = document.createElement(<span class="literal">"div"</span>);

    var iframeText =
      <span class="literal">'&lt;iframe name="'</span> + id + <span class="literal">'" id="'</span> + id +
      <span class="literal">'" src="about:blank" style="display:none"&gt;&lt;/iframe&gt;'</span>;
    outer.innerHTML = iframeText;

    var iframe = outer.firstChild;

    document.body.appendChild(iframe);

    <span class="reserved">return</span> iframe;
  }

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> createForm(id,
                      iframe,
                      action,
                      fields)
  {
    var target = iframe.getAttribute(<span class="literal">"name"</span>);

    var form = document.createElement(<span class="literal">"form"</span>);
    form.setAttribute(<span class="literal">"id"</span>, id);
    form.setAttribute(<span class="literal">"action"</span>, action);
    form.setAttribute(<span class="literal">"method"</span>, <span class="literal">"post"</span>);
    form.setAttribute(<span class="literal">"target"</span>, target);
    form.style.display = <span class="literal">"none"</span>;

    <span class="reserved">for</span> (var name in fields)
    {
      <span class="reserved">if</span> (fields.hasOwnProperty(name))
      {
        var value = fields[name];

        var input = document.createElement(<span class="literal">"input"</span>);
        input.setAttribute(<span class="literal">"name"</span>, name);
        input.setAttribute(<span class="literal">"value"</span>, value);
        input.setAttribute(<span class="literal">"type"</span>, <span class="literal">"hidden"</span>);  <span class="comment">// unnecessary since whole form is hidden!</span>

        form.appendChild(input);
      }
    }

    document.body.appendChild(form);

    <span class="reserved">return</span> form;
  }

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> encodeFieldsForURL(fields)
  {
    var urlFields = [];

    <span class="reserved">for</span> (var i in fields)
    {
      <span class="reserved">if</span> (fields.hasOwnProperty(i))
      {
        urlFields.push(encodeURIComponent(i) + <span class="literal">"="</span> + encodeURIComponent(fields[i]));
      }
    }

    <span class="reserved">return</span> urlFields.join(<span class="literal">"&amp;"</span>);
  }

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> simulateSubmit(frame,
                          url)
  {
    <span class="comment">// On Vista sidebar, we cannot do a form submission, since that breaks out</span>
    <span class="comment">// of the sidebar, and instead loads in a separate window.  To simulate the</span>
    <span class="comment">// submission, we instead write a new document in the frame that redirects</span>
    <span class="comment">// to where we really want to go.</span>

    <span class="comment">// We need this option to support Vista, so contentWindow is the place to write,</span>
    <span class="comment">// but for test purposes we also check the standards location first</span>
    var doc = frame.contentDocument || frame.contentWindow.document;

    <span class="comment">//CodeForTesting4 -- do not delete this line, it is used for automated testing</span>

    doc.write(<span class="literal">'&lt;meta http-equiv="refresh" content="0;url='</span> + url + <span class="literal">'" /&gt;'</span>);
    doc.close();

    <span class="comment">// Writing a new document can make the browser change the location url, so we need to</span>
    <span class="comment">// fetch what it thinks is current now, so that the polling code can tell when it changes</span>
    <span class="reserved">return</span> doc.location.href;
  }

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> pollForResponse(connection,
                           frameOrWindow,
                           successCallback,
                           failureCallback,
                           handleURL,
                           previousURL)   <span class="comment">// optional</span>
  {
    var poll = setInterval(<span class="reserved">function</span>()
    {
      <span class="reserved">if</span> (frameOrWindow.closed)
      {
        <span class="comment">// The user has closed the window</span>

        <span class="comment">// Stop polling</span>
        clearInterval(poll);

        queueError(failureCallback,
                   connection,
                   CommPortal.ERROR_LOGIN_WINDOW_CLOSED);
      }
      <span class="reserved">else</span>
      {
        try
        {
          <span class="comment">// Assume this window is an iframe - we need to check its content document</span>
          var url = frameOrWindow.contentDocument.location.href;
        }
        catch (e)
        {
          try
          {
            <span class="comment">// Try the IE iframe variant</span>
            var url = frameOrWindow.contentWindow.document.location.href;
          }
          catch (e2)
          {
            try
            {
              <span class="comment">// Lastly we check if this is a window not an iframe</span>
              var url = frameOrWindow.location.href;
            }
            catch (e3)
            {
            }
          }
        }

        <span class="comment">// Safari sends newly opened windows to a url of "/", whereas other</span>
        <span class="comment">// browsers use "about:blank"</span>
        <span class="reserved">if</span> (url &amp;&amp; url != <span class="literal">"about:blank"</span> &amp;&amp; url != <span class="literal">"/"</span> &amp;&amp; url != previousURL)
        {
          <span class="comment">// Stop polling</span>
          clearInterval(poll);

          <span class="comment">// Act on the parameters contained in the url</span>
          handleURL(url, connection, frameOrWindow, successCallback, failureCallback);
        }
      }
    },
    25);
  }

  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> toArray(object)
  {
    <span class="reserved">return</span> (object instanceof Array) ? object : [object];
  }

  <span class="comment">/**
   * Compare two version strings, e.g. "7.1" and "6.0".
   * Returns:
   *   -1 if firstVersion comes before secondVersion
   *   0 if the versions are the same
   *   1 if firstVersion comes after secondVersion.
   */</span>
  <span class="comment">/** <span class="attrib">@private</span> */</span>
  <span class="reserved">function</span> compareVersion(firstVersion, secondVersion)
  {
    var comp = 0;

    <span class="comment">// Split the version strings.</span>
    var splitVersionOne = firstVersion.split(<span class="literal">"."</span>);
    var splitVersionTwo = secondVersion.split(<span class="literal">"."</span>);

    <span class="comment">// Get the integer values.</span>
    var firstVersionMajor = parseInt(splitVersionOne[0], 10);
    var firstVersionMinor = parseInt(splitVersionOne[1], 10);
    var secondVersionMajor = parseInt(splitVersionTwo[0], 10);
    var secondVersionMinor = parseInt(splitVersionTwo[1], 10);

    <span class="comment">// Check the major version number first.</span>
    <span class="reserved">if</span> (firstVersionMajor &gt; secondVersionMajor)
    {
      comp = 1;
    }
    <span class="reserved">else</span> <span class="reserved">if</span> (firstVersionMajor &lt; secondVersionMajor)
    {
      comp = -1;
    }
    <span class="reserved">else</span>
    {
      <span class="comment">// Check the minor version number.</span>
      <span class="reserved">if</span> (firstVersionMinor &gt; secondVersionMinor)
      {
        comp = 1;
      }
      <span class="reserved">else</span> <span class="reserved">if</span> (firstVersionMinor &lt; secondVersionMinor)
      {
        comp = -1;
      }
    }

    <span class="reserved">return</span> comp;
  }

  <span class="comment">//---------------------------------------------------------------------------</span>
  <span class="comment">// The following empty functions are to make the documentation clearer</span>
  <span class="comment">// and are never explicitly called</span>
  <span class="comment">//---------------------------------------------------------------------------</span>

  <span class="comment">/**
   * &lt;i&gt;Ignore this constructor - this pseudo class just exists for documentation purposes.&lt;/i&gt;
   * <span class="attrib">@class</span>
   * The methods described here are callback methods that various methods
   * in the {<span class="attrib">@link</span> CommPortal} SDK API call.
   */</span>
  <span class="reserved">function</span> callbacks() {}

  <span class="comment">/**
   * General success callback signature used by a number of methods.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   */</span>
  callbacks.<span class="reserved">prototype</span>.successCallback = <span class="reserved">function</span>(connection) {};

  <span class="comment">/**
   * Success callback signature used by
   * {<span class="attrib">@link</span> CommPortal#login}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {String} sessionId the session id
   */</span>
  callbacks.<span class="reserved">prototype</span>.loginCallback = <span class="reserved">function</span>(connection, sessionId) {};

  <span class="comment">/**
   * Success callback signature used by
   * {<span class="attrib">@link</span> CommPortal#fetchToken}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {String} token the persistent login token
   */</span>
  callbacks.<span class="reserved">prototype</span>.tokenCallback = <span class="reserved">function</span>(connection, token) {};

  <span class="comment">/**
   * Success callback signature used by
   * {<span class="attrib">@link</span> CommPortal#fetchVoicemailCount} and
   * {<span class="attrib">@link</span> CommPortal#fetchFaxCount}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {Integer} total the total number of messages
   * <span class="attrib">@param</span> {Integer} unread the number of unread or unheard messages
   */</span>
  callbacks.<span class="reserved">prototype</span>.countsCallback = <span class="reserved">function</span>(connection, total, unread) {};

  <span class="comment">/**
   * Success callback signature used by
   * {<span class="attrib">@link</span> CommPortal#fetchVoicemails}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {voicemail[] voicemail} voicemails the array of voicemail objects
   */</span>
  callbacks.<span class="reserved">prototype</span>.voicemailsCallback = <span class="reserved">function</span>(connection, voicemails) {};

  <span class="comment">/**
   * Success callback signature used by
   * {<span class="attrib">@link</span> CommPortal#fetchFaxes}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {fax[] fax} faxes the array of fax objects
   */</span>
  callbacks.<span class="reserved">prototype</span>.faxesCallback = <span class="reserved">function</span>(connection, faxes) {};

  <span class="comment">/**
   * Success callback signature used by
   * {<span class="attrib">@link</span> CommPortal#fetchGreetings}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {greetings} greetingsdata greetings data
   */</span>
  callbacks.<span class="reserved">prototype</span>.greetingsCallback = <span class="reserved">function</span>(connection, greetingsdata) {};

  <span class="comment">/**
   * Success callback signature used by
   * {<span class="attrib">@link</span> CommPortal#fetchSubscriberNumber}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {String} number the phone number
   */</span>
  callbacks.<span class="reserved">prototype</span>.numberCallback = <span class="reserved">function</span>(connection, number) {};

  <span class="comment">/**
   * Success callback signature used by
   * {<span class="attrib">@link</span> CommPortal#fetchSubscriberName}.
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {String} name the subscribers name
   */</span>
  callbacks.<span class="reserved">prototype</span>.nameCallback = <span class="reserved">function</span>(connection, name) {};

  <span class="comment">/**
   * Success callback signature used by
   * {<span class="attrib">@link</span> CommPortal#fetchMissedCalls},
   * {<span class="attrib">@link</span> CommPortal#fetchDialedCalls},
   * {<span class="attrib">@link</span> CommPortal#fetchAnsweredCalls}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {call[] call} calls the array of call objects
   */</span>
  callbacks.<span class="reserved">prototype</span>.callsCallback = <span class="reserved">function</span>(connection, calls) {};

  <span class="comment">/**
   * Success callback signature used by
   * {<span class="attrib">@link</span> CommPortal#fetchContacts}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {contact[] contact} contacts the array of contact objects
   */</span>
  callbacks.<span class="reserved">prototype</span>.contactsCallback = <span class="reserved">function</span>(connection, contacts) {};

  <span class="comment">/**
   * Callback signature used by
   * {<span class="attrib">@link</span> CommPortal#performAction}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {Object} actionData the action data, whose structure varies
   *        by action type
   */</span>
  callbacks.<span class="reserved">prototype</span>.actionCallback = <span class="reserved">function</span>(connection, actionData) {};

  <span class="comment">/**
   * Callback signature used by
   * {<span class="attrib">@link</span> CommPortal#subscribeToEvents}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {String} number phone number of the line the event relates to
   * <span class="attrib">@param</span> {String} eventType the event type that occurred as passed to subscribeToEvents
   * <span class="attrib">@param</span> {Object} eventData the event data, whose structure varies by event type
   * <span class="attrib">@param</span> {String} eventSubType the event subtype (if applicable)
   */</span>
  callbacks.<span class="reserved">prototype</span>.eventCallback = <span class="reserved">function</span>(connection, number, eventType, eventData, eventSubType) {};

  <span class="comment">/**
   * Callback signature used by incoming call handler
   * {<span class="attrib">@link</span> CommPortal#setIncomingCallHandler}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {String} number line number the incoming call is on
   * <span class="attrib">@param</span> {incomingcalldata} callData the data containing the information
   *   about the incoming call
   */</span>
  callbacks.<span class="reserved">prototype</span>.incomingCallback = <span class="reserved">function</span>(connection, number, callData) {};

  <span class="comment">/**
   * General failure callback signature used by many methods.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {error} error the error that occured
   */</span>
  callbacks.<span class="reserved">prototype</span>.failureCallback = <span class="reserved">function</span>(connection, error) {};

  <span class="comment">/**
   * Progress callback signature used by
   * {<span class="attrib">@link</span> CommPortal#makeCall}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {String} callId the call ID
   * <span class="attrib">@param</span> {callstate} state the current progress state of the phone call
   */</span>
  callbacks.<span class="reserved">prototype</span>.progressCallback = <span class="reserved">function</span>(connection, callId, state) {};

  <span class="comment">/**
   * Success callback called once for each successfully returned piece of data
   * requested by {<span class="attrib">@link</span> CommPortal#fetchData}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {String} dataType the dataType as used by the JSON interface
   * <span class="attrib">@param</span> {Object} data the actual data, generally in a flattened and cleaned up form
   * <span class="attrib">@param</span> {Object} objectIdentity the object identity as delivered by the JSON interface
   */</span>
  callbacks.<span class="reserved">prototype</span>.fetchCallback = <span class="reserved">function</span>(connection, dataType, data, objectIdentity) {};

  <span class="comment">/**
   * Callback set to handle URL for fetching data.
   * <span class="attrib">@private</span>
   * <span class="attrib">@param</span> url the requested url
   */</span>
  callbacks.<span class="reserved">prototype</span>.getRequestCallback = <span class="reserved">function</span>(url) {};

  <span class="comment">/**
   * Callback set to handle fetched data
   * <span class="attrib">@private</span>
   * <span class="attrib">@param</span> callbackName the name of the callback used by the SDK when returning data
   * <span class="attrib">@param</span> objectIdentity the context of the current subscriber
   * <span class="attrib">@param</span> dataType the service indication
   * <span class="attrib">@param</span> getData the fetched data
   * <span class="attrib">@param</span> getErrors any errors in fetching the data
   * <span class="attrib">@param</span> updateData data to be updated (usually null)
   * <span class="attrib">@param</span> updateErrors errors updating data (usually null)
   */</span>
  callbacks.<span class="reserved">prototype</span>.getResponseCallback = <span class="reserved">function</span>(callbackName, objectIdentity,
                       dataType, getData, getErrors, updateData, updateErrors) {};

  <span class="comment">/**
   * Callback set to handle form built to make update request
   * <span class="attrib">@private</span>
   * <span class="attrib">@param</span> form DOM form object
   */</span>
  callbacks.<span class="reserved">prototype</span>.updateRequestCallback = <span class="reserved">function</span>(form) {};

  <span class="comment">/**
   * Callback set to handle update redirect url
   * <span class="attrib">@private</span>
   * <span class="attrib">@param</span> url redirect url
   */</span>
  callbacks.<span class="reserved">prototype</span>.updateResponseCallback = <span class="reserved">function</span>(url) {};

  <span class="comment">/**
   * Success callback set to handle fetched transcription settings used by
   * {<span class="attrib">@link</span> CommPortal#fetchTranscriptionEnabled}.
   * <span class="attrib">@param</span> {CommPortal} connection the connection in use
   * <span class="attrib">@param</span> {boolean} transcriptsEnabled whether STT transcriptions are enabled for this subscriber.
   */</span>
  callbacks.<span class="reserved">prototype</span>.transcriptsEnabledCallback = <span class="reserved">function</span>(connection, transcriptsEnabled) {};

  <span class="comment">/**
   * &lt;i&gt;Ignore this constructor - this pseudo class just exists for documentation purposes.&lt;/i&gt;
   * <span class="attrib">@class</span>
   * Pseudo class documenting the fields that describe a voicemail.
   */</span>
  <span class="reserved">function</span> voicemail() {}
  <span class="comment">/**
   * The phone number of the caller that left the voicemail, (missing if the number was withheld, or otherwise unavailable)
   * <span class="attrib">@type</span> String
   */</span>
  voicemail.<span class="reserved">prototype</span>.From = 0;
  <span class="comment">/**
   * The date and time when the voicemail was left (as a string)
   * <span class="attrib">@type</span> String
   */</span>
  voicemail.<span class="reserved">prototype</span>.Received = 0;
  <span class="comment">/**
   * A unique identifier for the voicemail - only valid within this login session
   * <span class="attrib">@type</span> String
   */</span>
  voicemail.<span class="reserved">prototype</span>.Id = 0;
  <span class="comment">/**
   * Not normally present, but may occur when the voicemail was sent from a system that is able to provide names as well as numbers
   * <span class="attrib">@type</span> String
   */</span>
  voicemail.<span class="reserved">prototype</span>.Name = 0;
  <span class="comment">/**
   * A boolean which is set if the voicemail has been marked as listened to
   * <span class="attrib">@type</span> boolean
   */</span>
  voicemail.<span class="reserved">prototype</span>.Read = 0;
  <span class="comment">/**
   * A boolean which is set if the voicemail has been marked as urgent
   * <span class="attrib">@type</span> boolean
   */</span>
  voicemail.<span class="reserved">prototype</span>.Urgent = 0;
  <span class="comment">/**
   * A boolean which is set if the voicemail has been marked as private
   * <span class="attrib">@type</span> boolean
   */</span>
  voicemail.<span class="reserved">prototype</span>.Private = 0;
  <span class="comment">/**
   * The size in bytes of the voicemail that was left
   * <span class="attrib">@type</span> Integer
   */</span>
  voicemail.<span class="reserved">prototype</span>.Size = 0;
  <span class="comment">/**
   * The URL of the wav file holding the voicemail audio - only valid within this login session
   * Requesting this file will implicitly mark the voicemail as heard, so after accessing this
   * you should call {<span class="attrib">@link</span> CommPortal#confirmVoicemailsHeard}.
   * <span class="attrib">@type</span> String
   */</span>
  voicemail.<span class="reserved">prototype</span>.AudioFile = 0;

  <span class="comment">/**
   * &lt;i&gt;Ignore this constructor - this pseudo class just exists for documentation purposes.&lt;/i&gt;
   * <span class="attrib">@class</span>
   * Pseudo class documenting the fields that describe a fax.
   */</span>
  <span class="reserved">function</span> fax() {}
  <span class="comment">/**
   * The phone number of the caller that sent the fax, (missing if the number was withheld, or otherwise unavailable)
   * <span class="attrib">@type</span> String
   */</span>
  fax.<span class="reserved">prototype</span>.From = 0;
  <span class="comment">/**
   * The date and time when the fax was sent (as a string)
   * <span class="attrib">@type</span> String
   */</span>
  fax.<span class="reserved">prototype</span>.Received = 0;
  <span class="comment">/**
   * A unique identifier for the fax - only valid within this login session
   * <span class="attrib">@type</span> String
   */</span>
  fax.<span class="reserved">prototype</span>.Id = 0;
  <span class="comment">/**
   * Not normally present, but may occur when the fax came from a system that is able to provide names as well as numbers
   * <span class="attrib">@type</span> String
   */</span>
  fax.<span class="reserved">prototype</span>.Name = 0;
  <span class="comment">/**
   * A boolean which is set if the fax has been marked as viewed
   * <span class="attrib">@type</span> boolean
   */</span>
  fax.<span class="reserved">prototype</span>.Read = 0;
  <span class="comment">/**
   * A boolean which is set if the fax has been marked as urgent
   * <span class="attrib">@type</span> boolean
   */</span>
  fax.<span class="reserved">prototype</span>.Urgent = 0;
  <span class="comment">/**
   * A boolean which is set if the fax has been marked as private
   * <span class="attrib">@type</span> boolean
   */</span>
  fax.<span class="reserved">prototype</span>.Private = 0;
  <span class="comment">/**
   * The size in bytes of the fax
   * <span class="attrib">@type</span> Integer
   */</span>
  fax.<span class="reserved">prototype</span>.Size = 0;
  <span class="comment">/**
   * The number of pages in the fax
   * <span class="attrib">@type</span> Integer
   */</span>
  fax.<span class="reserved">prototype</span>.Pages = 0;
  <span class="comment">/**
   * The URL of the tiff file holding the fax image - only valid within this login session.
   * Requesting this file will implicitly mark the fax as viewed, so after accessing this
   * you should call {<span class="attrib">@link</span> CommPortal#confirmFaxesViewed}.
   *
   * <span class="attrib">@type</span> String
   *
   * <span class="attrib">@see</span> CommPortal#confirmFaxesViewed
   */</span>
  fax.<span class="reserved">prototype</span>.ImageFile = 0;
  <span class="comment">/**
   * The URL of the pdf file holding the fax image - only valid within this login session.
   * Requesting this file will implicitly mark the fax as viewed, so after accessing this
   * you should call {<span class="attrib">@link</span> CommPortal#confirmFaxesViewed}.
   *
   * <span class="attrib">@type</span> String
   *
   * <span class="attrib">@see</span> CommPortal#confirmFaxesViewed
   */</span>
  fax.<span class="reserved">prototype</span>.ImageFilePDF = 0;

  <span class="comment">/**
   * &lt;i&gt;Ignore this constructor - this pseudo class just exists for documentation purposes.&lt;/i&gt;
   * <span class="attrib">@class</span>
   * Pseudo class documenting the fields that describe greetings data.
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   */</span>
  <span class="reserved">function</span> greetings() {}

  <span class="comment">/**
   * Details for each of the available greetings for the subscriber
   *
   * <span class="attrib">@type</span> greeting[]
   */</span>
  greetings.<span class="reserved">prototype</span>.greetingsList = 0;

  <span class="comment">/**
   * The current default greeting type.
   *
   * <span class="attrib">@type</span> String
   */</span>
  greetings.<span class="reserved">prototype</span>.defaultGreetingType = 0;

  <span class="comment">/**
   * &lt;i&gt;Ignore this constructor - this pseudo class just exists for documentation purposes.&lt;/i&gt;
   * <span class="attrib">@class</span>
   * Pseudo class documenting the fields that describe greetings data.
   *
   * &lt;p&gt;New in version 7.3&lt;/p&gt;
   */</span>
  <span class="reserved">function</span> greeting() {}

  <span class="comment">/**
   * Whether this greeting is available for being the default greeting
   *
   * <span class="attrib">@type</span> Boolean
   */</span>
  greeting.<span class="reserved">prototype</span>.availableForDefault = 0;

  <span class="comment">/**
   * Whether this greeting can be recorded
   *
   * <span class="attrib">@type</span> Boolean
   */</span>
  greeting.<span class="reserved">prototype</span>.recordable = 0;

  <span class="comment">/**
   * The type of this greeting
   *
   * <span class="attrib">@type</span> String
   */</span>
  greeting.<span class="reserved">prototype</span>.greetingType = 0;

  <span class="comment">/**
   * Whether this greeting is recorded
   *
   * <span class="attrib">@type</span> Boolean
   */</span>
  greeting.<span class="reserved">prototype</span>.isRecorded = 0;

  <span class="comment">/**
   * A URL at which the greeting file can be accessed
   *
   * <span class="attrib">@type</span> String
   */</span>
  greeting.<span class="reserved">prototype</span>.audioFile = 0;

  <span class="comment">/**
   * &lt;i&gt;Ignore this constructor - this pseudo class just exists for documentation purposes.&lt;/i&gt;
   * <span class="attrib">@class</span>
   * Pseudo class documenting the fields that describe a contact.
   */</span>
  <span class="reserved">function</span> contact() {}

  <span class="comment">/**
   * The first or given name of the person
   * <span class="attrib">@type</span> String
   */</span>
  contact.<span class="reserved">prototype</span>.givenName = 0;
  <span class="comment">/**
   * The surname or family name of the person
   * <span class="attrib">@type</span> String
   */</span>
  contact.<span class="reserved">prototype</span>.familyName = 0;
  <span class="comment">/**
   * A convenient combination of the given and family names
   * <span class="attrib">@type</span> String
   */</span>
  contact.<span class="reserved">prototype</span>.displayName = 0;
  <span class="comment">/**
   * A familiar name or nickname of the person
   * <span class="attrib">@type</span> String
   */</span>
  contact.<span class="reserved">prototype</span>.nickname = 0;
  <span class="comment">/**
   * The organization the person is associated with - often their employer
   * <span class="attrib">@type</span> String
   */</span>
  contact.<span class="reserved">prototype</span>.organization = 0;
  <span class="comment">/**
   * The person's job title
   * <span class="attrib">@type</span> String
   */</span>
  contact.<span class="reserved">prototype</span>.jobTitle = 0;
  <span class="comment">/**
   * The person's sms contact details
   * <span class="attrib">@type</span> String
   */</span>
  contact.<span class="reserved">prototype</span>.sms = 0;
  <span class="comment">/**
   * An id that identifies this contact object for other API calls
   * <span class="attrib">@type</span> String
   */</span>
  contact.<span class="reserved">prototype</span>.uid = 0;
  <span class="comment">/**
   * An array of up to 5 phone numbers that can be used to contact the person
   * <span class="attrib">@type</span> String[0-5]
   */</span>
  contact.<span class="reserved">prototype</span>.phone = 0;
  <span class="comment">/**
   * This array mirrors the phone array field, and for each entry provides a
   * type for the corresponding number - one of "home", "work", "cell", "fax" or empty.
   * <span class="attrib">@type</span> String[0-5]
   */</span>
  contact.<span class="reserved">prototype</span>.phoneType = 0;
  <span class="comment">/**
   * An array of up to 2 email addresses that can be used to contact the person
   * <span class="attrib">@type</span> String[0-2]
   */</span>
  contact.<span class="reserved">prototype</span>.email = 0;
  <span class="comment">/**
   * An array of up to 2 postal {<span class="attrib">@link</span> address} that can be used to contact the person.
   * <span class="attrib">@type</span> address[0-2]
   */</span>
  contact.<span class="reserved">prototype</span>.address = 0;
  <span class="comment">/**
   * This array mirrors the address array field, and for each entry provides a
   * type for the corresponding address - one of "home" or "work"
   * <span class="attrib">@type</span> String[0-2]
   */</span>
  contact.<span class="reserved">prototype</span>.addressType = 0;

  <span class="comment">/**
   * &lt;i&gt;Ignore this constructor - this pseudo class just exists for documentation purposes.&lt;/i&gt;
   * <span class="attrib">@class</span>
   * Pseudo class documenting the fields that form an address within a {<span class="attrib">@link</span> contact}.
   */</span>
  <span class="reserved">function</span> address() {}

  <span class="comment">/**
   * The street part of the address
   * <span class="attrib">@type</span> String
   */</span>
  address.<span class="reserved">prototype</span>.street = 0;
  <span class="comment">/**
   * The locality part of the address - for a US address this is typically the city
   * <span class="attrib">@type</span> String
   */</span>
  address.<span class="reserved">prototype</span>.locality = 0;
  <span class="comment">/**
   * For a US address this typically holds the State (or state abbreviation)
   * <span class="attrib">@type</span> String
   */</span>
  address.<span class="reserved">prototype</span>.region = 0;
  <span class="comment">/**
   * For a US address this holds the ZIP code
   * <span class="attrib">@type</span> String
   */</span>
  address.<span class="reserved">prototype</span>.postalcode = 0;
  <span class="comment">/**
   * As it says, the country part of the address
   * <span class="attrib">@type</span> String
   */</span>
  address.<span class="reserved">prototype</span>.country = 0;
  <span class="comment">/**
   * A convenience field - which joins together the various parts of the address into one value
   * <span class="attrib">@type</span> String
   */</span>
  address.<span class="reserved">prototype</span>.displayAddress = 0;

  <span class="comment">/**
   * &lt;i&gt;Ignore this constructor - this pseudo class just exists for documentation purposes.&lt;/i&gt;
   * <span class="attrib">@class</span>
   * Pseudo class documenting the fields that make up a call record.
   */</span>
  <span class="reserved">function</span> call() {}
  <span class="comment">/**
   * May be present if the network provided a name when identifying the caller
   * <span class="attrib">@type</span> String
   */</span>
  call.<span class="reserved">prototype</span>.Name = 0;
  <span class="comment">/**
   * The phone number that was involved in this call, if available
   * <span class="attrib">@type</span> String
   */</span>
  call.<span class="reserved">prototype</span>.DirectoryNumber = 0;
  <span class="comment">/**
   * The date and time the call was dialed - as an English language string
   * <span class="attrib">@type</span> String
   */</span>
  call.<span class="reserved">prototype</span>.DateTime = 0;
  <span class="comment">/**
   * If this represents something other than a missed call,
   * the duration of the call, in seconds
   * <span class="attrib">@type</span> Integer
   */</span>
  call.<span class="reserved">prototype</span>.Duration = 0;

  <span class="comment">/**
   * &lt;i&gt;Ignore this constructor - this pseudo class just exists for documentation purposes.&lt;/i&gt;
   * <span class="attrib">@class</span>
   * Pseudo class documenting the properties that make up a callstate passed to the
   * {<span class="attrib">@link</span> callbacks#progressCallback} of a {<span class="attrib">@link</span> CommPortal#makeCall}.
   */</span>
  <span class="reserved">function</span> callstate() {}

  <span class="comment">/**
   * A numeric value that identifies which state the call is in.
   *
   * One of
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#CALLSTATE_CALLING}&lt;/li&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#CALLSTATE_FIRST_RINGING}&lt;/li&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#CALLSTATE_FIRST_ANSWERED}&lt;/li&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#CALLSTATE_SECOND_RINGING}&lt;/li&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#CALLSTATE_SECOND_ANSWERED}&lt;/li&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#CALLSTATE_CLEARING}&lt;/li&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#CALLSTATE_CLEARED}&lt;/li&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#CALLSTATE_FAILED}&lt;/li&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#CALLSTATE_FINAL}&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * <span class="attrib">@type</span> Integer
   */</span>
  callstate.<span class="reserved">prototype</span>.state = 0;
  <span class="comment">/**
   * An English language explanation of the state (which will also be returned
   * if you call toString() on this object).
   *
   * <span class="attrib">@type</span> String
   */</span>
  callstate.<span class="reserved">prototype</span>.message = 0;

  <span class="comment">/**
   * &lt;i&gt;Ignore this constructor - this pseudo class just exists for documentation purposes.&lt;/i&gt;
   * <span class="attrib">@class</span>
   * Pseudo class documenting the properties that make up an error passed to a
   * {<span class="attrib">@link</span> callbacks#failureCallback}.
   */</span>
  <span class="reserved">function</span> error() {}

  <span class="comment">/**
   * A numeric value that identifies what error occured.
   * <span class="attrib">@type</span> Integer
   */</span>
  error.<span class="reserved">prototype</span>.id = 0;
  <span class="comment">/**
   * An English language explanation of the error (which will also be returned
   * if you call toString() on this object).
   *
   * <span class="attrib">@type</span> String
   */</span>
  error.<span class="reserved">prototype</span>.message = 0;

  <span class="comment">/**
   * &lt;i&gt;Ignore this constructor - this pseudo class just exists for documentation purposes.&lt;/i&gt;
   * <span class="attrib">@class</span>
   * Pseudo class documenting the properties that make up a incomingcalldata
   * passed to the {<span class="attrib">@link</span> callbacks#incomingCallback} of a
   * {<span class="attrib">@link</span> CommPortal#setIncomingCallHandler}.
   *
   * &lt;p&gt;New in version 7.1&lt;/p&gt;
   */</span>
  <span class="reserved">function</span> incomingcalldata() {};

  <span class="comment">/**
   * A unique identifier for this call
   * <span class="attrib">@type</span> String
   */</span>
  incomingcalldata.<span class="reserved">prototype</span>.callID = 0;
  <span class="comment">/**
   * A string value that identifies which state the call is in. (whether or not
   * the subscriber's phone is ringing)
   *
   * &lt;p&gt;
   * One of
   * &lt;/p&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#INCOMINGCALLSTATE_RINGING}&lt;/li&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#INCOMINGCALLSTATE_NOT_RINGING}&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * <span class="attrib">@type</span> String
   */</span>
  incomingcalldata.<span class="reserved">prototype</span>.callState = 0;
  <span class="comment">/**
   * A string value containing the phone number that is receiving the call
   * <span class="attrib">@type</span> String
   */</span>
  incomingcalldata.<span class="reserved">prototype</span>.number = 0;
  <span class="comment">/**
   * A string value containing the caller phone number (available only when the
   * call state is {<span class="attrib">@link</span> CommPortal#INCOMINGCALLSTATE_RINGING} and if the
   * number is known)
   * <span class="attrib">@type</span> String
   */</span>
  incomingcalldata.<span class="reserved">prototype</span>.callerNumber = 0;
  <span class="comment">/**
   * A string value that identifies the call type
   *
   * &lt;p&gt;
   * One of
   * &lt;/p&gt;
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#INCOMINGCALLTYPE_NORMAL}&lt;/li&gt;
   *   &lt;li&gt;{<span class="attrib">@link</span> CommPortal#INCOMINGCALLTYPE_LIVE_MESSAGE_SCREENING}&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * <span class="attrib">@type</span> String
   */</span>
  incomingcalldata.<span class="reserved">prototype</span>.callType = 0;

})();

<span class="comment">/* Revision: $Rev$, $Date$ */</span>
</pre>
        <hr>



<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">

  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev"> &nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> <font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top"><em>
<b></b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<font size="-1">

</font>
<div>Documentation generated by <a href="http://code.google.com/p/jsdoc-toolkit/" target="_parent">JSDoc</a></div>
</body>
</html>
